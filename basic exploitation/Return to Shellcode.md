# Return to Shellcode

kĩ thuật này được dùng khi NX của binary không được bật, user có khả năng control flow được eip(rip) của chương trình để trỏ vào shellcode nằm trên stack

## CALL & RET
-	để có thể hiểu được ret2shellcode thì ta phải hiểu được 2 instruction này: call và ret
	-	Call:	lưu ret addr(vị trí ở sau call instruction) vào stack và vào trong hàm call
	-	ret:	dùng `POP` để lưu giá trị trỏ bởi RSP vào RIP(EIP), rồi sau đó đi tiếp flow của chương trình
	-	Nói cách khác, nếu giá trị địa chỉ lưu trong stack có thể thay đổi, thì flow của binary cũng có thể thay đổi


|Instruction|Processing|
|-----------|----------|
| call (operation) |PUSH ReturnAddress<br>JMP (operation) |
|ret|POP RIP <br>JMP RIP|

example: source này đơn giản sẽ gọi vuln() từ main(), và vuln() không làm gì cả.

![](https://i.imgur.com/JDC8Njd.png)

-	như chúng ta có thể thấy, trước khi call vuln() nó có hiện trạng như thế này

![](https://i.imgur.com/YEf1GdN.png)

-	sau khi call:

![](https://i.imgur.com/p31t8uq.png)

như mọi người đã thấy, lúc này đỉnh của stack chính là instruction kế tiếp sau khi call vuln() (tức `0x4004ac`),  và rip của chúng ta bây giờ đang trỏ vào vuln()

-	đến hàm ret của vuln():

![](https://i.imgur.com/XAPTEnL.png)

khi ta nhảy tiếp thì chương trình sẽ `pop rip` từ đỉnh stack, sau đó `jmp rip`

![](https://i.imgur.com/a3DBXiC.png)

## Proof of Concept

source: (nhớ tắt DEP lúc biên dịch binary (-zexecstack) )
```c
#include <stdio.h>
#include <unistd.h>
 
void vuln(){
    char buf[50];
    printf("buf[50] address : %p\n",buf); // leak stack address
    read(0, buf, 100);
}
 
void main(){
    vuln();
}
```
![](https://i.imgur.com/E0Drj8o.png)

bây giờ chúng ta có thể control được rip, và có cả địa chỉ stack đã leak bên trên vậy nếu ta pad shellcode vào địa chỉ stack trên ta có thể gain shell của binary

![](https://i.imgur.com/z9lW6PS.png)
![](https://i.imgur.com/rpP2IuQ.png)